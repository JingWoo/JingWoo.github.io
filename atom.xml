<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jingwoo.github.io</id>
    <title>WuJing&apos;s Blog</title>
    <updated>2020-08-01T08:29:21.861Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jingwoo.github.io"/>
    <link rel="self" href="https://jingwoo.github.io/atom.xml"/>
    <subtitle>总在夕阳落下，沉眠之中，又会迎来另一片晨阳.</subtitle>
    <logo>https://jingwoo.github.io/images/avatar.png</logo>
    <icon>https://jingwoo.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, WuJing&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Linux程序调试与性能分析]]></title>
        <id>https://jingwoo.github.io/post/linux-cheng-xu-diao-shi-yu-xing-neng-fen-xi/</id>
        <link href="https://jingwoo.github.io/post/linux-cheng-xu-diao-shi-yu-xing-neng-fen-xi/">
        </link>
        <updated>2020-08-01T08:26:59.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="1-gdb-调试利器">1. gdb 调试利器</h1>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p>
<h2 id="11-启动gdb">1.1. 启动gdb</h2>
<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<pre><code>$g++ -g hello.cpp -o hello
</code></pre>
<p>调试可执行文件:</p>
<pre><code>$gdb &lt;program&gt;
</code></pre>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<pre><code>$gdb &lt;program&gt; &lt;core dump file&gt;
$gdb program core.11127
</code></pre>
<p>调试服务程序:</p>
<pre><code>$gdb &lt;program&gt; &lt;PID&gt;
$gdb hello 11127
</code></pre>
<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="12-gdb交互命令">1.2. gdb交互命令</h2>
<p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h3 id="运行">运行</h3>
<ul>
<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>
<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>
<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>
<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>
<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>
<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>
<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>
<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>
<li>quit：简记为 q ，退出gdb</li>
</ul>
<h3 id="设置断点">设置断点</h3>
<ul>
<li>
<ul>
<li>
<p>break n （简写b n）:在第n行处设置断点</p>
<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>
</li>
</ul>
</li>
<li>
<p>b fn1 if a＞b：条件断点设置</p>
</li>
<li>
<p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>
</li>
<li>
<p>delete 断点号n：删除第n个断点</p>
</li>
<li>
<p>disable 断点号n：暂停第n个断点</p>
</li>
<li>
<p>enable 断点号n：开启第n个断点</p>
</li>
<li>
<p>clear 行号n：清除第n行的断点</p>
</li>
<li>
<p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>
</li>
<li>
<p>delete breakpoints：清除所有断点：</p>
</li>
</ul>
<h3 id="查看源代码">查看源代码</h3>
<ul>
<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>
<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>
<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>
<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>
</ul>
<h3 id="打印表达式">打印表达式</h3>
<ul>
<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>
<li>print a：将显示整数 a 的值</li>
<li>print ++a：将把 a 中的值加1,并显示出来</li>
<li>print name：将显示字符串 name 的值</li>
<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>
<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>
<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>
<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>
<li>whatis ：查询变量或函数</li>
<li>info function： 查询函数</li>
<li>扩展info locals： 显示当前堆栈页的所有变量</li>
</ul>
<h3 id="查询运行信息">查询运行信息</h3>
<ul>
<li>where/bt ：当前运行的堆栈列表；</li>
<li>bt backtrace 显示当前调用堆栈</li>
<li>up/down 改变堆栈显示的深度</li>
<li>set args 参数:指定运行时的参数</li>
<li>show args：查看设置好的参数</li>
<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>
</ul>
<h3 id="分割窗口">分割窗口</h3>
<ul>
<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>
<li>layout src：显示源代码窗口</li>
<li>layout asm：显示反汇编窗口</li>
<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>
<li>layout split：显示源代码和反汇编窗口</li>
<li>Ctrl + L：刷新窗口</li>
</ul>
<p>注解</p>
<p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便；</p>
<h2 id="13-更强大的工具">1.3. 更强大的工具</h2>
<h3 id="cgdb">cgdb</h3>
<p>cgdb可以看作gdb的界面增强版,用来替代gdb的 gdb -tui。cgdb主要功能是在调试时进行代码的同步显示，这无疑增加了调试的方便性，提高了调试效率。界面类似vi，符合unix/linux下开发人员习惯;如果熟悉gdb和vi，几乎可以立即使用cgdb。</p>
<h1 id="2-ldd-查看程序依赖库">2. ldd 查看程序依赖库</h1>
<ul>
<li>
<p>ldd</p>
<p>作用：用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。</p>
</li>
</ul>
<p>示例：查看test程序运行所依赖的库:</p>
<pre><code>/opt/app/todeav1/test$ldd test
libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)
libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)
libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003995800000)
/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)
</code></pre>
<ul>
<li>第一列：程序需要依赖什么库</li>
<li>第二列: 系统提供的与程序需要的库所对应的库</li>
<li>第三列：库加载的开始地址</li>
</ul>
<p>通过上面的信息，我们可以得到以下几个信息：</p>
<ol>
<li>通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配</li>
<li>通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置</li>
</ol>
<p>如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在；</p>
<p>注解</p>
<p>原理： ldd不是个可执行程式，而只是个shell脚本； ldd显示可执行模块的dependency的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现的。ld-linux.so模块会先于executable模块程式工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。</p>
<h1 id="3-lsof-一切皆文件">3. lsof 一切皆文件</h1>
<p>lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</p>
<p>lsof打开的文件可以是：</p>
<ol>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络socket，unix域名socket）</li>
<li>还有其它类型的文件，等等</li>
</ol>
<h2 id="31-命令参数">3.1. 命令参数</h2>
<ul>
<li>-a 列出打开文件存在的进程</li>
<li>-c&lt;进程名&gt; 列出指定进程所打开的文件</li>
<li>-g 列出GID号进程详情</li>
<li>-d&lt;文件号&gt; 列出占用该文件号的进程</li>
<li>+d&lt;目录&gt; 列出目录下被打开的文件</li>
<li>+D&lt;目录&gt; 递归列出目录下被打开的文件</li>
<li>-n&lt;目录&gt; 列出使用NFS的文件</li>
<li>-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</li>
<li>-p&lt;进程号&gt; 列出指定进程号所打开的文件</li>
<li>-u 列出UID号进程详情</li>
<li>-h 显示帮助信息</li>
<li>-v 显示版本信息</li>
</ul>
<h2 id="32-使用实例">3.2. 使用实例</h2>
<h3 id="实例1无任何参数">实例1：无任何参数</h3>
<pre><code>$lsof| more
COMMAND     PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
init          1      root  cwd       DIR              253,0     4096          2 /
init          1      root  rtd       DIR              253,0     4096          2 /
init          1      root  txt       REG              253,0   150352    1310795 /sbin/init
init          1      root  mem       REG              253,0    65928    5505054 /lib64/libnss_files-2.12.so
init          1      root  mem       REG              253,0  1918016    5521405 /lib64/libc-2.12.so
init          1      root  mem       REG              253,0    93224    5521440 /lib64/libgcc_s-4.4.6-20120305.so.1
init          1      root  mem       REG              253,0    47064    5521407 /lib64/librt-2.12.so
init          1      root  mem       REG              253,0   145720    5521406 /lib64/libpthread-2.12.so
...
</code></pre>
<p>说明：</p>
<p>lsof输出各列信息的意义如下：</p>
<ul>
<li>
<p>COMMAND：进程的名称</p>
</li>
<li>
<p>PID：进程标识符</p>
</li>
<li>
<p>PPID：父进程标识符（需要指定-R参数）</p>
</li>
<li>
<p>USER：进程所有者</p>
</li>
<li>
<p>PGID：进程所属组</p>
</li>
<li>
<p>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等:</p>
<pre><code>（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改
（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序
（3）lnn：library references (AIX);
（4）er：FD information error (see NAME column);
（5）jld：jail directory (FreeBSD);
（6）ltx：shared library text (code and data);
（7）mxx ：hex memory-mapped type number xx.
（8）m86：DOS Merge mapped file;
（9）mem：memory-mapped file;
（10）mmap：memory-mapped device;
（11）pd：parent directory;
（12）rtd：root directory;
（13）tr：kernel trace file (OpenBSD);
（14）v86  VP/ix mapped file;
（15）0：表示标准输入
（16）1：表示标准输出
（17）2：表示标准错误
一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等
（1）u：表示该文件被打开并处于读取/写入模式
（2）r：表示该文件被打开并处于只读模式
（3）w：表示该文件被打开并处于
（4）空格：表示该文件的状态模式为unknow，且没有锁定
（5）-：表示该文件的状态模式为unknow，且被锁定
同时在文件状态模式后面，还跟着相关的锁
（1）N：for a Solaris NFS lock of unknown type;
（2）r：for read lock on part of the file;
（3）R：for a read lock on the entire file;
（4）w：for a write lock on part of the file;（文件的部分写锁）
（5）W：for a write lock on the entire file;（整个文件的写锁）
（6）u：for a read and write lock of any length;
（7）U：for a lock of unknown type;
（8）x：for an SCO OpenServer Xenix lock on part      of the file;
（9）X：for an SCO OpenServer Xenix lock on the      entire file;
（10）space：if there is no lock.
</code></pre>
</li>
<li>
<p>TYPE：文件类型，如DIR、REG等，常见的文件类型:</p>
<pre><code>（1）DIR：表示目录
（2）CHR：表示字符类型
（3）BLK：块设备类型
（4）UNIX： UNIX 域套接字
（5）FIFO：先进先出 (FIFO) 队列
（6）IPv4：网际协议 (IP) 套接字
</code></pre>
</li>
<li>
<p>DEVICE：指定磁盘的名称</p>
</li>
<li>
<p>SIZE：文件的大小</p>
</li>
<li>
<p>NODE：索引节点（文件在磁盘上的标识）</p>
</li>
<li>
<p>NAME：打开文件的确切名称</p>
</li>
</ul>
<h3 id="实例2查找某个文件相关的进程">实例2：查找某个文件相关的进程</h3>
<pre><code>$lsof /bin/bash
COMMAND     PID USER  FD   TYPE DEVICE SIZE/OFF    NODE NAME
mysqld_sa  2169 root txt    REG  253,0   938736 4587562 /bin/bash
ksmtuned   2334 root txt    REG  253,0   938736 4587562 /bin/bash
bash      20121 root txt    REG  253,0   938736 4587562 /bin/bash
</code></pre>
<h3 id="实例3列出某个用户打开的文件信息">实例3：列出某个用户打开的文件信息</h3>
<pre><code>   $lsof -u username

-u 选项，u是user的缩写
</code></pre>
<h3 id="实例4列出某个程序进程所打开的文件信息">实例4：列出某个程序进程所打开的文件信息</h3>
<pre><code>$lsof -c mysql
</code></pre>
<p>-c 选项将会列出所有以mysql这个进程开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符；</p>
<h3 id="实例5列出某个用户以及某个进程所打开的文件信息">实例5：列出某个用户以及某个进程所打开的文件信息</h3>
<pre><code>$lsof  -u test -c mysql
</code></pre>
<h3 id="实例6通过某个进程号显示该进程打开的文件">实例6：通过某个进程号显示该进程打开的文件</h3>
<pre><code>$lsof -p 11968
</code></pre>
<h3 id="实例7列出所有的网络连接">实例7：列出所有的网络连接</h3>
<pre><code>$lsof -i
</code></pre>
<h3 id="实例8列出所有tcp-网络连接信息">实例8：列出所有tcp 网络连接信息</h3>
<pre><code>$lsof -i tcp

$lsof -n -i tcp
COMMAND     PID  USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
svnserve  11552 weber    3u  IPv4 3799399      0t0  TCP *:svn (LISTEN)
redis-ser 25501 weber    4u  IPv4  113150      0t0  TCP 127.0.0.1:6379 (LISTEN)
</code></pre>
<h3 id="实例9列出谁在使用某个端口">实例9：列出谁在使用某个端口</h3>
<pre><code>$lsof -i :3306
</code></pre>
<h3 id="实例10列出某个用户的所有活跃的网络端口">实例10：列出某个用户的所有活跃的网络端口</h3>
<pre><code>$lsof -a -u test -i
</code></pre>
<h3 id="实例11根据文件描述列出对应的文件信息">实例11：根据文件描述列出对应的文件信息</h3>
<pre><code>$lsof -d description(like 2)
</code></pre>
<p>示例:</p>
<pre><code>$lsof -d 3 | grep PARSER1
tail      6499 tde    3r   REG    253,3   4514722     417798 /opt/applog/open/log/HOSTPARSER1_ERROR_141217.log.001
</code></pre>
<p>说明： 0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</p>
<h3 id="实例12列出被进程号为1234的进程所打开的所有ipv4-network-files">实例12：列出被进程号为1234的进程所打开的所有IPV4 network files</h3>
<pre><code>$lsof -i 4 -a -p 1234
</code></pre>
<h3 id="实例13列出目前连接主机nf5260i5-td上端口为202180相关的所有文件信息且每隔3秒重复执行">实例13：列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行</h3>
<pre><code>lsof -i @nf5260i5-td:20,21,80 -r 3
</code></pre>
<h1 id="4-ps-进程查看器">4. ps 进程查看器</h1>
<p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
<p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p>
<p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html#top">top linux下的任务管理器</a> 工具。</p>
<p>注：kill 命令用于杀死进程。</p>
<p>linux上进程有5种状态:</p>
<ol>
<li>运行(正在运行或在运行队列中等待)</li>
<li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>
<li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>
<li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</li>
<li>停止(进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行)</li>
</ol>
<p>ps工具标识进程的5种状态码:</p>
<ul>
<li>D 不可中断 uninterruptible sleep (usually IO)</li>
<li>R 运行 runnable (on run queue)</li>
<li>S 中断 sleeping</li>
<li>T 停止 traced or stopped</li>
<li>Z 僵死 a defunct (”zombie”) process</li>
</ul>
<h2 id="41-命令参数">4.1. 命令参数</h2>
<ul>
<li>a 显示所有进程</li>
<li>-a 显示同一终端下的所有程序</li>
<li>-A 显示所有进程</li>
<li>c 显示进程的真实名称</li>
<li>-N 反向选择</li>
<li>-e 等于“-A”</li>
<li>e 显示环境变量</li>
<li>f 显示程序间的关系</li>
<li>-H 显示树状结构</li>
<li>r 显示当前终端的进程</li>
<li>T 显示当前终端的所有程序</li>
<li>u 指定用户的所有进程</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
<li>-C&lt;命令&gt; 列出指定命令的状况</li>
<li>–lines&lt;行数&gt; 每页显示的行数</li>
<li>–width&lt;字符数&gt; 每页显示的字符数</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本显示</li>
</ul>
<h2 id="42-输出列的含义">4.2. 输出列的含义</h2>
<ul>
<li>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li>
<li>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</li>
<li>UID 程序被该 UID 所拥有</li>
<li>PID 进程的ID</li>
<li>PPID 则是其上级父程序的ID</li>
<li>C CPU 使用的资源百分比</li>
<li>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</li>
<li>NI 这个是 Nice 值，在下一小节我们会持续介绍</li>
<li>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</li>
<li>SZ 使用掉的内存大小</li>
<li>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</li>
<li>TTY 登入者的终端机位置</li>
<li>TIME 使用掉的 CPU 时间。</li>
<li>CMD 所下达的指令为何</li>
</ul>
<h2 id="43-使用实例">4.3. 使用实例</h2>
<h3 id="实例1显示所有进程信息">实例1：显示所有进程信息</h3>
<pre><code>[root@localhost test6]# ps -A
PID TTY          TIME CMD
1 ?        00:00:00 init
2 ?        00:00:01 migration/0
3 ?        00:00:00 ksoftirqd/0
4 ?        00:00:01 migration/1
5 ?        00:00:00 ksoftirqd/1
6 ?        00:29:57 events/0
7 ?        00:00:00 events/1
8 ?        00:00:00 khelper
49 ?        00:00:00 kthread
54 ?        00:00:00 kblockd/0
55 ?        00:00:00 kblockd/1
56 ?        00:00:00 kacpid
217 ?        00:00:00 cqueue/0
……省略部分结果
</code></pre>
<h3 id="实例2显示指定用户信息">实例2：显示指定用户信息</h3>
<pre><code>[root@localhost test6]# ps -u root
PID TTY          TIME CMD
1 ?        00:00:00 init
2 ?        00:00:01 migration/0
3 ?        00:00:00 ksoftirqd/0
4 ?        00:00:01 migration/1
5 ?        00:00:00 ksoftirqd/1
6 ?        00:29:57 events/0
7 ?        00:00:00 events/1
8 ?        00:00:00 khelper
49 ?        00:00:00 kthread
54 ?        00:00:00 kblockd/0
55 ?        00:00:00 kblockd/1
56 ?        00:00:00 kacpid
……省略部分结果
</code></pre>
<h3 id="实例3显示所有进程信息连同命令行">实例3：显示所有进程信息，连同命令行</h3>
<pre><code>[root@localhost test6]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Nov02 ?        00:00:00 init [3]
root         2     1  0 Nov02 ?        00:00:01 [migration/0]
root         3     1  0 Nov02 ?        00:00:00 [ksoftirqd/0]
root         4     1  0 Nov02 ?        00:00:01 [migration/1]
root         5     1  0 Nov02 ?        00:00:00 [ksoftirqd/1]
root         6     1  0 Nov02 ?        00:29:57 [events/0]
root         7     1  0 Nov02 ?        00:00:00 [events/1]
root         8     1  0 Nov02 ?        00:00:00 [khelper]
root        49     1  0 Nov02 ?        00:00:00 [kthread]
root        54    49  0 Nov02 ?        00:00:00 [kblockd/0]
root        55    49  0 Nov02 ?        00:00:00 [kblockd/1]
root        56    49  0 Nov02 ?        00:00:00 [kacpid]
</code></pre>
<h3 id="实例4-ps-与grep-组合使用查找特定进程">实例4： ps 与grep 组合使用，查找特定进程</h3>
<pre><code>[root@localhost test6]# ps -ef|grep ssh
root      2720     1  0 Nov02 ?        00:00:00 /usr/sbin/sshd
root     17394  2720  0 14:58 ?        00:00:00 sshd: root@pts/0
root     17465 17398  0 15:57 pts/0    00:00:00 grep ssh
</code></pre>
<h3 id="实例5将与这次登入的-pid-与相关信息列示出来">实例5：将与这次登入的 PID 与相关信息列示出来</h3>
<pre><code>[root@localhost test6]# ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 17398 17394  0  75   0 - 16543 wait   pts/0    00:00:00 bash
4 R     0 17469 17398  0  77   0 - 15877 -      pts/0    00:00:00 ps
</code></pre>
<h3 id="实例6列出目前所有的正在内存中的程序">实例6：列出目前所有的正在内存中的程序</h3>
<pre><code>[root@localhost test6]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  10368   676 ?        Ss   Nov02   0:00 init [3]
root         2  0.0  0.0      0     0 ?        S&lt;   Nov02   0:01 [migration/0]
root         3  0.0  0.0      0     0 ?        SN   Nov02   0:00 [ksoftirqd/0]
root         4  0.0  0.0      0     0 ?        S&lt;   Nov02   0:01 [migration/1]
root         5  0.0  0.0      0     0 ?        SN   Nov02   0:00 [ksoftirqd/1]
root         6  0.0  0.0      0     0 ?        S&lt;   Nov02  29:57 [events/0]
root         7  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [events/1]
root         8  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [khelper]
root        49  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kthread]
root        54  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kblockd/0]
root        55  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kblockd/1]
root        56  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kacpid]
</code></pre>
<h1 id="5-pstack-跟踪进程栈">5. pstack 跟踪进程栈</h1>
<p>此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。请参见 proc(1) 手册页。</p>
<p>这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p>
<p>示例：查看bash程序进程栈:</p>
<pre><code>/opt/app/tdev1$ps -fe| grep bash
tdev1   7013  7012  0 19:42 pts/1    00:00:00 -bash
tdev1  11402 11401  0 20:31 pts/2    00:00:00 -bash
tdev1  11474 11402  0 20:32 pts/2    00:00:00 grep bash
/opt/app/tdev1$pstack 7013
#0  0x00000039958c5620 in __read_nocancel () from /lib64/libc.so.6
#1  0x000000000047dafe in rl_getc ()
#2  0x000000000047def6 in rl_read_key ()
#3  0x000000000046d0f5 in readline_internal_char ()
#4  0x000000000046d4e5 in readline ()
#5  0x00000000004213cf in ?? ()
#6  0x000000000041d685 in ?? ()
#7  0x000000000041e89e in ?? ()
#8  0x00000000004218dc in yyparse ()
#9  0x000000000041b507 in parse_command ()
#10 0x000000000041b5c6 in read_command ()
#11 0x000000000041b74e in reader_loop ()
#12 0x000000000041b2aa in main ()
</code></pre>
<h1 id="6-strace-跟踪进程中的系统调用">6. strace 跟踪进程中的系统调用</h1>
<p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>
<h2 id="61-输出参数含义">6.1. 输出参数含义</h2>
<p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p>
<pre><code>$strace cat /dev/null
execve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;], [/* 22 vars */]) = 0
brk(0)                                  = 0xab1000
access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000
access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)
...
</code></pre>
<h2 id="62-参数">6.2. 参数</h2>
<pre><code>-c 统计每一系统调用的所执行的时间,次数和出错的次数等.
-d 输出strace关于标准错误的调试信息.
-f 跟踪由fork调用所产生的子进程.
-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.
-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.
-h 输出简要的帮助信息.
-i 输出系统调用的入口指针.
-q 禁止输出关于脱离的消息.
-r 打印出相对时间关于,,每一个系统调用.
-t 在输出中的每一行前加上时间信息.
-tt 在输出中的每一行前加上时间信息,微秒级.
-ttt 微秒级输出,以秒了表示时间.
-T 显示每一调用所耗的时间.
-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.
-V 输出strace的版本信息.
-x 以十六进制形式输出非标准字符串
-xx 所有字符串以十六进制形式输出.
-a column
设置返回值的输出位置.默认 为40.
-e expr
指定一个表达式,用来控制如何跟踪.格式如下:
[qualifier=][!]value1[,value2]...
qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:
-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.
注意有些shell使用!来执行历史记录里的命令,所以要使用\\.
-e trace=set
只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.
-e trace=file
只跟踪有关文件操作的系统调用.
-e trace=process
只跟踪有关进程控制的系统调用.
-e trace=network
跟踪与网络有关的所有系统调用.
-e strace=signal
跟踪所有与系统信号有关的 系统调用
-e trace=ipc
跟踪所有与进程通讯有关的系统调用
-e abbrev=set
设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.
-e raw=set
将指 定的系统调用的参数以十六进制显示.
-e signal=set
指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.
-e read=set
输出从指定文件中读出 的数据.例如:
-e read=3,5
-e write=set
输出写入到指定文件中的数据.
-o filename
将strace的输出写入文件filename
-p pid
跟踪指定的进程pid.
-s strsize
指定输出的字符串的最大长度.默认为32.文件名一直全部输出.
-u username
以username 的UID和GID执行被跟踪的命令
</code></pre>
<h2 id="63-命令实例">6.3. 命令实例</h2>
<h3 id="跟踪可执行程序">跟踪可执行程序</h3>
<pre><code>strace -f -F -o ~/straceout.txt myserver
</code></pre>
<p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<h3 id="跟踪服务程序">跟踪服务程序</h3>
<pre><code>strace -o output.txt -T -tt -e trace=all -p 28979
</code></pre>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
<h1 id="7-ipcs-查询进程间通信状态">7. ipcs 查询进程间通信状态</h1>
<p>ipcs是Linux下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息。对于程序员非常有用，普通的系统管理员一般用不到此指令。</p>
<h2 id="71-ipc资源查询">7.1. IPC资源查询</h2>
<h3 id="查看系统使用的ipc资源">查看系统使用的IPC资源</h3>
<pre><code>$ipcs

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0x00000000 229376     weber      600        1

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</code></pre>
<p>分别查询IPC资源:</p>
<pre><code>$ipcs -m 查看系统使用的IPC共享内存资源
$ipcs -q 查看系统使用的IPC队列资源
$ipcs -s 查看系统使用的IPC信号量资源
</code></pre>
<h3 id="查看ipc资源被谁占用">查看IPC资源被谁占用</h3>
<p>示例：有个IPCKEY(51036)，需要查询其是否被占用；</p>
<ol>
<li>
<p>首先通过计算器将其转为十六进制:</p>
<pre><code>51036 -&gt; c75c
</code></pre>
</li>
<li>
<p>如果知道是被共享内存占用:</p>
<pre><code>$ipcs -m | grep c75c
0x0000c75c 40403197   tdea3    666        536870912  2
</code></pre>
</li>
<li>
<p>如果不确定，则直接查找:</p>
<pre><code>$ipcs | grep c75c
0x0000c75c 40403197   tdea3    666        536870912  2
0x0000c75c 5079070    tdea3    666        4
</code></pre>
</li>
</ol>
<h2 id="72-系统ipc参数查询">7.2. 系统IPC参数查询</h2>
<pre><code>ipcs -l

------ Shared Memory Limits --------
max number of segments = 4096
max seg size (kbytes) = 4194303
max total shared memory (kbytes) = 1073741824
min seg size (bytes) = 1

------ Semaphore Limits --------
max number of arrays = 128
max semaphores per array = 250
max semaphores system wide = 32000
max ops per semop call = 32
semaphore max value = 32767

------ Messages: Limits --------
max queues system wide = 2048
max size of message (bytes) = 524288
default max size of queue (bytes) = 5242880
</code></pre>
<p>以上输出显示，目前这个系统的允许的最大内存为1073741824kb；最大可使用128个信号量，每个消息的最大长度为524288bytes；</p>
<h2 id="73-修改ipc系统参数">7.3. 修改IPC系统参数</h2>
<p>以linux系统为例，在root用户下修改/etc/sysctl.conf 文件，保存后使用sysctl -p生效:</p>
<pre><code>$cat /etc/sysctl.conf
# 一个消息的最大长度
kernel.msgmax = 524288

# 一个消息队列上的最大字节数
# 524288*10
kernel.msgmnb = 5242880

#最大消息队列的个数
kernel.msgmni=2048

#一个共享内存区的最大字节数
kernel.shmmax = 17179869184

#系统范围内最大共享内存标识数
kernel.shmmni=4096

#每个信号灯集的最大信号灯数 系统范围内最大信号灯数 每个信号灯支持的最大操作数 系统范围内最大信号灯集数
#此参数为系统默认，可以不用修改
#kernel.sem = &lt;semmsl&gt; &lt;semmni&gt;*&lt;semmsl&gt; &lt;semopm&gt; &lt;semmni&gt;
kernel.sem = 250 32000 32 128
</code></pre>
<p>显示输入不带标志的 ipcs：的输出:</p>
<pre><code>$ipcs
IPC status from /dev/mem as of Mon Aug 14 15:03:46 1989
T    ID         KEY        MODE       OWNER     GROUP
Message Queues:
q       0    0x00010381 -Rrw-rw-rw-   root      system
q   65537    0x00010307 -Rrw-rw-rw-   root      system
q   65538    0x00010311 -Rrw-rw-rw-   root      system
q   65539    0x0001032f -Rrw-rw-rw-   root      system
q   65540    0x0001031b -Rrw-rw-rw-   root      system
q   65541    0x00010339--rw-rw-rw-    root      system
q       6    0x0002fe03 -Rrw-rw-rw-   root      system
Shared Memory:
m   65537    0x00000000 DCrw-------   root      system
m  720898    0x00010300 -Crw-rw-rw-   root      system
m   65539    0x00000000 DCrw-------   root      system
Semaphores:
s  131072    0x4d02086a --ra-ra----   root      system
s   65537    0x00000000 --ra-------   root      system
s 1310722    0x000133d0 --ra-------   7003      30720
</code></pre>
<h2 id="74-清除ipc资源">7.4. 清除IPC资源</h2>
<p>使用ipcrm 命令来清除IPC资源：这个命令同时会将与ipc对象相关联的数据也一起移除。当然，只有root用户，或者ipc对象的创建者才有这项权利；</p>
<p>ipcrm用法:</p>
<pre><code>ipcrm -M shmkey  移除用shmkey创建的共享内存段
ipcrm -m shmid    移除用shmid标识的共享内存段
ipcrm -Q msgkey  移除用msqkey创建的消息队列
ipcrm -q msqid  移除用msqid标识的消息队列
ipcrm -S semkey  移除用semkey创建的信号
ipcrm -s semid  移除用semid标识的信号
</code></pre>
<p>清除当前用户创建的所有的IPC资源:</p>
<pre><code>ipcs -q | awk '{ print &quot;ipcrm -q &quot;$2}' | sh &gt; /dev/null 2&gt;&amp;1;
ipcs -m | awk '{ print &quot;ipcrm -m &quot;$2}' | sh &gt; /dev/null 2&gt;&amp;1;
ipcs -s | awk '{ print &quot;ipcrm -s &quot;$2}' | sh &gt; /dev/null 2&gt;&amp;1;
</code></pre>
<h2 id="75-综合应用">7.5. 综合应用</h2>
<h3 id="查询user1用户环境上是否存在积queue现象">查询user1用户环境上是否存在积Queue现象</h3>
<ol>
<li>
<p>查询队列Queue:</p>
<pre><code>$ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0x49060005 58261504   user1    660        0            0
0x4f060005 58294273   user1    660        0            0
...
</code></pre>
</li>
<li>
<p>找出第6列大于0的服务:</p>
<pre><code>$ ipcs -q |grep user1 |awk '{if($5&gt;0) print $0}'
0x00000000 1071579324 user1       644        1954530      4826
0x00000000 1071644862 user1       644        1961820      4844
0x00000000 1071677631 user1       644        1944810      4802
0x00000000 1071710400 user1       644        1961820      4844
</code></pre>
</li>
</ol>
<h1 id="8-top-linux下的任务管理器">8. top linux下的任务管理器</h1>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</p>
<pre><code>$top
    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00
    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie
    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st
    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers
    Swap:   397308k total,    67192k used,   330116k free,    71900k cached
    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd
    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0
    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0
</code></pre>
<ul>
<li>
<ul>
<li>
<p>第一行</p>
<p>09:14:56 ： 系统当前时间264 days, 20:56 ： 系统开机到现在经过了多少时间1 users ： 当前2用户在线load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第二行</p>
<p>Tasks：任务;87 total：很好理解，就是当前有87个任务，也就是87个进程。1 running：1个进程正在运行86 sleeping：86个进程睡眠0 stopped：停止的进程数0 zombie：僵死的进程数</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第三行</p>
<p>Cpu(s)：表示这一行显示CPU总体信息0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。0.7%sy：内核占用CPU时间百分比0.0%ni：改变过优先级的进程占用CPU的百分比99.3%id：空闲CPU时间百分比0.0%wa：等待I/O的CPU时间百分比0.0%hi：CPU硬中断时间百分比0.0%si：CPU软中断时间百分比注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第四行</p>
<p>Men：内存的意思8175320kk total：物理内存总量8058868k used：使用的物理内存量116452k free：空闲的物理内存量283084k buffers：用作内核缓存的物理内存量</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第五行</p>
<p>Swap：交换空间6881272k total：交换区总量4010444k used：使用的交换区量2870828k free：空闲的交换区量4336992k cached：缓冲交换区总量</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>进程信息</p>
<p>再下面就是进程信息：PID：进程的IDUSER：进程所有者PR：进程的优先级别，越小越优先被执行NInice：值VIRT：进程占用的虚拟内存RES：进程占用的物理内存SHR：进程使用的共享内存S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数%CPU：进程占用CPU的使用率%MEM：进程使用的物理内存和总内存的百分比TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。COMMAND：进程启动命令名称</p>
</li>
</ul>
</li>
</ul>
<h2 id="81-top命令交互操作指令">8.1. top命令交互操作指令</h2>
<p>下面列出一些常用的 top命令操作指令</p>
<blockquote>
<ul>
<li>q：退出top命令</li>
<li><Space>：立即刷新</li>
<li>s：设置刷新时间间隔</li>
<li>c：显示命令完全模式</li>
<li>t:：显示或隐藏进程和CPU状态信息</li>
<li>m：显示或隐藏内存状态信息</li>
<li>l：显示或隐藏uptime信息</li>
<li>f：增加或减少进程显示标志</li>
<li>S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+</li>
<li>P：按%CPU使用率排行</li>
<li>T：按MITE+排行</li>
<li>M：按%MEM排行</li>
<li>u：指定显示用户进程</li>
<li>r：修改进程renice值</li>
<li>kkill：进程</li>
<li>i：只显示正在运行的进程</li>
<li>W：保存对top的设置到文件^/.toprc，下次启动将自动调用toprc文件的设置。</li>
<li>h：帮助命令。</li>
<li>q：退出</li>
</ul>
</blockquote>
<p>注：强调一下，使用频率最高的是P、T、M，因为通常使用top，我们就想看看是哪些进程最耗cpu资源、占用的内存最多； 注：通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列 如果只需要查看内存：可用free命令。只查看uptime信息（第一行），可用uptime命令；</p>
<h2 id="82-实例">8.2. 实例</h2>
<h3 id="实例1多核cpu监控">实例1：多核CPU监控</h3>
<p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况；</p>
<pre><code>[rdtfr@bl685cb4-t ^]$ top
top - 09:10:44 up 20 days, 16:51,  4 users,  load average: 3.82, 4.40, 4.40
Tasks: 1201 total,  10 running, 1189 sleeping,   0 stopped,   2 zombie
Cpu0  :  1.3%us,  2.3%sy,  0.0%ni, 96.4%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu1  :  1.3%us,  2.6%sy,  0.0%ni, 96.1%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu2  :  1.0%us,  2.0%sy,  0.0%ni, 92.5%id,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st
Cpu3  :  3.9%us,  7.8%sy,  0.0%ni, 83.2%id,  0.0%wa,  0.0%hi,  5.2%si,  0.0%st
Cpu4  :  4.2%us, 10.4%sy,  0.0%ni, 63.8%id,  0.0%wa,  0.0%hi, 21.5%si,  0.0%st
Cpu5  :  6.8%us, 12.7%sy,  0.0%ni, 80.5%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu6  :  2.9%us,  7.2%sy,  0.0%ni, 85.3%id,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st
Cpu7  :  6.2%us, 13.0%sy,  0.0%ni, 75.3%id,  0.0%wa,  0.0%hi,  5.5%si,  0.0%st
Mem:  32943888k total, 32834216k used,   109672k free,   642704k buffers
Swap: 35651576k total,  5761928k used, 29889648k free, 16611500k cached
</code></pre>
<h3 id="实例2高亮显示当前运行进程">实例2：高亮显示当前运行进程</h3>
<pre><code>在top基本视图中,按键盘“b”（打开/关闭加亮效果）；
</code></pre>
<h3 id="实例3显示完整的程序命令">实例3：显示完整的程序命令</h3>
<p>命令：top -c</p>
<pre><code>[rdtfr@bl685cb4-t ^]$ top -c
top - 09:14:35 up 20 days, 16:55,  4 users,  load average: 5.77, 5.01, 4.64
Tasks: 1200 total,   5 running, 1192 sleeping,   0 stopped,   3 zombie
Cpu(s):  4.4%us,  6.0%sy,  0.0%ni, 83.8%id,  0.2%wa,  0.0%hi,  5.5%si,  0.0%st
Mem:  32943888k total, 32842896k used,   100992k free,   591484k buffers
Swap: 35651576k total,  5761808k used, 29889768k free, 16918824k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
2013 apache    18   0  403m  88m 5304 S 25.0  0.3   6:37.44 /usr/sbin/httpd
18335 pubtest   22   0 65576  996  728 R  7.8  0.0   0:00.24 netstat -naltp
16499 rdtfare   15   0 13672 2080  824 R  2.6  0.0   0:00.38 top -c
29684 rdtfare   15   0 1164m 837m  14m S  2.3  2.6 148:47.54 ./autodata data1.txt
12976 pubtest   18   0  238m 9000 1932 S  1.6  0.0 439:28.44 tscagent -s TOEV_P
</code></pre>
<h3 id="实例4显示指定的进程信息">实例4：显示指定的进程信息</h3>
<p>命令：top -p pidid</p>
<pre><code>/opt/app/tdv1/config#top -p 17265
top - 09:17:34 up 455 days, 17:55,  2 users,  load average: 3.76, 4.56, 4.46
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
Cpu(s):  7.8%us,  1.9%sy,  0.0%ni, 89.2%id,  0.0%wa,  0.1%hi,  1.0%si,  0.0%st
Mem:   8175452k total,  8103988k used,    71464k free,   268716k buffers
Swap:  6881272k total,  4275424k used,  2605848k free,  6338184k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
17265 tdv1      15   0 56504  828  632 S  0.0  0.0 195:53.25 redis-server
</code></pre>
<p>指定进程信息有多个时，需要结合其它工具将回车替换为,（-p 支持pid,pid,pid语法）</p>
<p>命令：top -p pgrep MULTI_PROCESS | tr “\n” ”,” | sed ‘s/,$//’</p>
<pre><code>/opt/app/tdv1$top -p `pgrep java | tr &quot;\\n&quot; &quot;,&quot; | sed 's/,$//'`
top - 14:05:31 up 53 days,  2:43,  9 users,  load average: 0.29, 0.34, 0.22
Tasks:   3 total,   0 running,   3 sleeping,   0 stopped,   0 zombie
Cpu(s):  5.9%us,  8.2%sy,  0.0%ni, 86.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:  66082088k total, 29512860k used, 36569228k free,   756352k buffers
Swap: 32767992k total,  1019900k used, 31748092k free, 15710284k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                          27855 rdtfare   20   0 4454m 1.3g 5300 S  0.7  2.0 338:31.37 java
 2034 jenkins   20   0 18.3g 5.2g 5284 S  0.3  8.2  56:02.38 java                                             12156 rdtfare   20   0 4196m 1.2g  12m S  0.3  2.0  86:34.62 java
</code></pre>
<h2 id="83-更强大的工具">8.3. 更强大的工具</h2>
<h3 id="htop">htop</h3>
<p>htop 是一个 Linux 下的交互式的进程浏览器，可以用来替换Linux下的top命令。</p>
<p>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>
<p>与top相比，htop有以下优点：</p>
<ul>
<li>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</li>
<li>在启动上，比top 更快。</li>
<li>杀进程时不需要输入进程号。</li>
<li>htop 支持鼠标操作。</li>
</ul>
<h1 id="9-free-查询可用内存">9. free 查询可用内存</h1>
<p>free工具用来查看系统可用内存:</p>
<pre><code>/opt/app/tdev1$free
             total       used       free     shared    buffers     cached
Mem:       8175320    6159248    2016072          0     310208    5243680
-/+ buffers/cache:     605360    7569960
Swap:      6881272      16196    6865076
</code></pre>
<p>解释一下Linux上free命令的输出。</p>
<p>下面是free的运行结果，一共有4行。为了方便说明，我加上了列号。这样可以把free的输出看成一个二维数组FO(Free Output)。例如:</p>
<pre><code>FO[2][1] = 24677460
FO[3][2] = 10321516

                   1          2          3          4          5          6
1              total       used       free     shared    buffers     cached
2 Mem:      24677460   23276064    1401396          0     870540   12084008
3 -/+ buffers/cache:   10321516   14355944
4 Swap:     25151484     224188   24927296
</code></pre>
<p>free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。</p>
<p>free输出地第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。</p>
<p>第一行的输出时从操作系统（OS）来看的。也就是说，从OS的角度来看，计算机上一共有:</p>
<p>24677460KB（缺省时free的单位为KB）物理内存，即FO[2][1]； 在这些物理内存中有23276064KB（即FO[2][2]）被使用了； 还用1401396KB（即FO[2][3]）是可用的；</p>
<p>这里得到第一个等式：</p>
<p>FO[2][1] = FO[2][2] + FO[2][3]</p>
<p>FO[2][4]表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的）。</p>
<p>FO[2][5]表示被OS buffer住的内存。FO[2][6]表示被OS cache的内存。在有些时候buffer和cache这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:</p>
<pre><code>A buffer is something that has yet to be &quot;written&quot; to disk.
A cache is something that has been &quot;read&quot; from the disk and stored for later use.
</code></pre>
<p>也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。</p>
<p>Linux和其他成熟的操作系统（例如windows），为了提高IO read的性能，总是要多cache一些数据，这也就是为什么FO[2][6]（cached memory）比较大，而FO[2][3]比较小的原因。我们可以做一个简单的测试:</p>
<p>释放掉被系统cache占用的数据:</p>
<pre><code>echo 3&gt;/proc/sys/vm/drop_caches
</code></pre>
<ol>
<li>读一个大文件，并记录时间；</li>
<li>关闭该文件；</li>
<li>重读这个大文件，并记录时间；</li>
</ol>
<p>第二次读应该比第一次快很多。原来我做过一个BerkeleyDB的读操作，大概要读5G的文件，几千万条记录。在我的环境上，第二次读比第一次大概可以快9倍左右。</p>
<p>free输出的第二行是从一个应用程序的角度看系统内存的使用情况。</p>
<ul>
<li>对于FO[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；</li>
<li>对于FO[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；</li>
</ul>
<p>因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多。</p>
<p>这里还用两个等式:</p>
<pre><code>FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
</code></pre>
<p>这二者都不难理解。</p>
<p>free命令由procps.*.rpm提供（在Redhat系列的OS上）。free命令的所有输出值都是从/proc/meminfo中读出的。</p>
<p>在系统上可能有meminfo(2)这个函数，它就是为了解析/proc/meminfo的。procps这个包自己实现了meminfo()这个函数。可以下载一个procps的tar包看看具体实现，现在最新版式3.2.8。</p>
<h1 id="10-vmstat-监视内存使用情况">10. vmstat 监视内存使用情况</h1>
<p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。</p>
<h2 id="101-vmstat的语法">10.1. vmstat的语法</h2>
<p>vmstat [-V] [-n] [delay [count]]</p>
<blockquote>
<ul>
<li>-V表示打印出版本信息；</li>
<li>-n表示在周期性循环输出时，输出的头部信息仅显示一次；</li>
<li>delay是两次输出之间的延迟时间；</li>
<li>count是指按照这个时间间隔统计的次数。</li>
</ul>
</blockquote>
<pre><code>/root$vmstat 5 5
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
6  0      0 27900472 204216 28188356    0    0     0     9    1    2 11 14 75  0  0
9  0      0 27900380 204228 28188360    0    0     0    13 33312 126221 22 20 58  0  0
2  0      0 27900340 204240 28188364    0    0     0    10 32755 125566 22 20 58  0  0
</code></pre>
<h2 id="102-字段说明">10.2. 字段说明</h2>
<ul>
<li>
<p>Procs（进程）:</p>
<p>r: 运行队列中进程数量b: 等待IO的进程数量</p>
</li>
<li>
<p>Memory（内存）:</p>
<p>swpd: 使用虚拟内存大小free: 可用内存大小buff: 用作缓冲的内存大小cache: 用作缓存的内存大小</p>
</li>
<li>
<p>Swap:</p>
<p>si: 每秒从交换区写到内存的大小so: 每秒写入交换区的内存大小</p>
</li>
<li>
<p>IO：（现在的Linux版本块的大小为1024bytes）</p>
<p>bi: 每秒读取的块数bo: 每秒写入的块数</p>
</li>
<li>
<p>system：</p>
<p>in: 每秒中断数，包括时钟中断cs: 每秒上下文切换数</p>
</li>
<li>
<p>CPU（以百分比表示）</p>
<p>us: 用户进程执行时间(user time)sy: 系统进程执行时间(system time)id: 空闲时间(包括IO等待时间)wa: 等待IO时间</p>
</li>
</ul>
<h1 id="11-iostat-监视io子系统">11. iostat 监视I/O子系统</h1>
<p>iostat是I/O statistics（输入/输出统计）的缩写，用来动态监视系统的磁盘操作活动。</p>
<h2 id="111-命令格式">11.1. 命令格式</h2>
<p>iostat[参数][时间][次数]</p>
<h2 id="112-命令功能">11.2. 命令功能</h2>
<p>通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。</p>
<h2 id="113-命令参数">11.3. 命令参数</h2>
<ul>
<li>-C 显示CPU使用情况</li>
<li>-d 显示磁盘使用情况</li>
<li>-k 以 KB 为单位显示</li>
<li>-m 以 M 为单位显示</li>
<li>-N 显示磁盘阵列(LVM) 信息</li>
<li>-n 显示NFS 使用情况</li>
<li>-p[磁盘] 显示磁盘和分区的情况</li>
<li>-t 显示终端和CPU的信息</li>
<li>-x 显示详细信息</li>
<li>-V 显示版本信息</li>
</ul>
<h2 id="114-工具实例">11.4. 工具实例</h2>
<h3 id="实例1显示所有设备负载情况">实例1：显示所有设备负载情况</h3>
<pre><code>/root$iostat
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
10.81    0.00   14.11    0.18    0.00   74.90

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               1.95         1.48        70.88    9145160  437100644
dm-0              3.08         0.55        24.34    3392770  150087080
dm-1              5.83         0.93        46.49    5714522  286724168
dm-2              0.01         0.00         0.05      23930     289288
</code></pre>
<ul>
<li>
<p>cpu属性值说明：</p>
<p>%user：CPU处在用户模式下的时间百分比。%nice：CPU处在带NICE值的用户模式下的时间百分比。%system：CPU处在系统模式下的时间百分比。%iowait：CPU等待输入输出完成时间的百分比。%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。%idle：CPU空闲时间百分比。</p>
</li>
</ul>
<p>注：如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p>
<ul>
<li>
<p>disk属性值说明：</p>
<p>rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/swrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/sr/s: 每秒完成的读 I/O 设备次数。即 rio/sw/s: 每秒完成的写 I/O 设备次数。即 wio/srsec/s: 每秒读扇区数。即 rsect/swsec/s: 每秒写扇区数。即 wsect/srkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。wkB/s: 每秒写K字节数。是 wsect/s 的一半。avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。avgqu-sz: 平均I/O队列长度。await: 平均每次设备I/O操作的等待时间 (毫秒)。svctm: 平均每次设备I/O操作的服务时间 (毫秒)。%util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</p>
</li>
</ul>
<p>备注：如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有当量io在等待。</p>
<h3 id="实例2定时显示所有信息">实例2：定时显示所有信息</h3>
<pre><code>/root$iostat 2 3
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
10.81    0.00   14.11    0.18    0.00   74.90

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               1.95         1.48        70.88    9145160  437106156
dm-0              3.08         0.55        24.34    3392770  150088376
dm-1              5.83         0.93        46.49    5714522  286728384
dm-2              0.01         0.00         0.05      23930     289288

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
22.62    0.00   19.67    0.26    0.00   57.46

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               2.50         0.00        28.00          0         56
dm-0              0.00         0.00         0.00          0          0
dm-1              3.50         0.00        28.00          0         56
dm-2              0.00         0.00         0.00          0          0

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
22.69    0.00   19.62    0.00    0.00   57.69

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               0.00         0.00         0.00          0          0
dm-0              0.00         0.00         0.00          0          0
dm-1              0.00         0.00         0.00          0          0
dm-2              0.00         0.00         0.00          0          0
</code></pre>
<p>说明：每隔 2秒刷新显示，且显示3次</p>
<h3 id="实例3查看tps和吞吐量">实例3：查看TPS和吞吐量</h3>
<pre><code>/root$iostat -d -k 1 1
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               1.95         0.74        35.44    4572712  218559410
dm-0              3.08         0.28        12.17    1696513   75045968
dm-1              5.83         0.46        23.25    2857265  143368744
dm-2              0.01         0.00         0.02      11965     144644
</code></pre>
<ul>
<li>tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。</li>
<li>kB_read/s：每秒从设备（drive expressed）读取的数据量；</li>
<li>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</li>
<li>kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；</li>
</ul>
<p>这些单位都为Kilobytes。</p>
<p>上面的例子中，我们可以看到磁盘sda以及它的各个分区的统计数据，当时统计的磁盘总TPS是1.95，下面是各个分区的TPS。（因为是瞬间值，所以总TPS并不严格等于各个分区TPS的总和）</p>
<h3 id="实例4查看设备使用率util和响应时间await">实例4：查看设备使用率（%util）和响应时间（await）</h3>
<pre><code>/root$iostat -d -x -k 1 1
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.02     7.25    0.04    1.90     0.74    35.47    37.15     0.04   19.13   5.58   1.09
dm-0              0.00     0.00    0.04    3.05     0.28    12.18     8.07     0.65  209.01   1.11   0.34
dm-1              0.00     0.00    0.02    5.82     0.46    23.26     8.13     0.43   74.33   1.30   0.76
dm-2              0.00     0.00    0.00    0.01     0.00     0.02     8.00     0.00    5.41   3.28   0.00
</code></pre>
<ul>
<li>rrqm/s： 每秒进行 merge 的读操作数目.即 delta(rmerge)/s</li>
<li>wrqm/s： 每秒进行 merge 的写操作数目.即 delta(wmerge)/s</li>
<li>r/s： 每秒完成的读 I/O 设备次数.即 delta(rio)/s</li>
<li>w/s： 每秒完成的写 I/O 设备次数.即 delta(wio)/s</li>
<li>rsec/s： 每秒读扇区数.即 delta(rsect)/s</li>
<li>wsec/s： 每秒写扇区数.即 delta(wsect)/s</li>
<li>rkB/s： 每秒读K字节数.是 rsect/s 的一半,因为每扇区大小为512字节.(需要计算)</li>
<li>wkB/s： 每秒写K字节数.是 wsect/s 的一半.(需要计算)</li>
<li>avgrq-sz：平均每次设备I/O操作的数据大小 (扇区).delta(rsect+wsect)/delta(rio+wio)</li>
<li>avgqu-sz：平均I/O队列长度.即 delta(aveq)/s/1000 (因为aveq的单位为毫秒).</li>
<li>await： 平均每次设备I/O操作的等待时间 (毫秒).即 delta(ruse+wuse)/delta(rio+wio)</li>
<li>svctm： 平均每次设备I/O操作的服务时间 (毫秒).即 delta(use)/delta(rio+wio)</li>
<li>%util： 一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的，即 delta(use)/s/1000 (因为use的单位为毫秒)</li>
</ul>
<p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。 idle小于70% IO压力就较大了，一般读取速度有较多的wait。 同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比，高过30%时IO压力高)。</p>
<p>另外 await 的参数也要多和 svctm 来参考。差的过高就一定有 IO 的问题。</p>
<p>avgqu-sz 也是个做 IO 调优时需要注意的地方，这个就是直接每次操作的数据的大小，如果次数多，但数据拿的小的话，其实 IO 也会很小。如果数据拿的大，才IO 的数据会高。也可以通过 avgqu-sz × ( r/s or w/s ) = rsec/s or wsec/s。也就是讲，读定速度是这个来决定的。</p>
<p>svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了)，svctm 的大小一般和磁盘性能有关，CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm 的增加。await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算法，优化应用，或者升级 CPU。</p>
<p>队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。</p>
<ul>
<li>
<p>形象的比喻：</p>
<p>r/s+w/s 类似于交款人的总数平均队列长度(avgqu-sz)类似于单位时间里平均排队人的个数平均服务时间(svctm)类似于收银员的收款速度平均等待时间(await)类似于平均每人的等待时间平均I/O数据(avgrq-sz)类似于平均每人所买的东西多少I/O 操作率 (%util)类似于收款台前有人排队的时间比例</p>
</li>
</ul>
<p>设备IO操作:总IO(io)/s = r/s(读) +w/s(写)</p>
<p>平均等待时间=单个I/O服务器时间*(1+2+...+请求总数-1)/请求总数</p>
<p>每秒发出的I/0请求很多,但是平均队列就4,表示这些请求比较均匀,大部分处理还是比较及时。</p>
<h1 id="12-sar-找出系统瓶颈的利器">12. sar 找出系统瓶颈的利器</h1>
<p>sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。sar是目前Linux上最为全面的系统性能分析工具之一，可以从14个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU效率、内存使用状况、进程活动及IPC有关的活动等，使用也是较为复杂。</p>
<p>sar是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法；</p>
<ol>
<li>追溯过去的统计数据（默认）</li>
<li>周期性的查看当前数据</li>
</ol>
<h2 id="121-追溯过去的统计数据">12.1. 追溯过去的统计数据</h2>
<p>默认情况下，sar从最近的0点0分开始显示数据；如果想继续查看一天前的报告；可以查看保存在/var/log/sysstat/下的sa日志； 使用sar工具查看:</p>
<pre><code>$sar -f /var/log/sysstat/sa28 \| head sar -r -f
/var/log/sysstat/sa28
</code></pre>
<figure data-type="image" tabindex="1"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar1.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar1.png" alt="../_images/sar1.png" loading="lazy"></a></figure>
<h2 id="122-查看cpu使用率">12.2. 查看CPU使用率</h2>
<p>sar -u : 默认情况下显示的cpu使用率等信息就是sar -u；</p>
<figure data-type="image" tabindex="2"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar2.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar2.png" alt="../_images/sar2.png" loading="lazy"></a></figure>
<p>可以看到这台机器使用了虚拟化技术，有相应的时间消耗； 各列的指标分别是:</p>
<ul>
<li>%user 用户模式下消耗的CPU时间的比例；</li>
<li>%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>
<li>%system 系统模式下消耗的CPU时间的比例；</li>
<li>%iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；</li>
<li>%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</li>
<li>%idle CPU空闲时间比例；</li>
</ul>
<h2 id="123-查看平均负载">12.3. 查看平均负载</h2>
<p>sar -q: 查看平均负载</p>
<p>指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等；与其它命令相比，它能查看各项指标随时间变化的情况；</p>
<ul>
<li>runq-sz：运行队列的长度（等待运行的进程数）</li>
<li>plist-sz：进程列表中进程（processes）和线程（threads）的数量</li>
<li>ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载</li>
<li>ldavg-15：过去15分钟的系统平均负载</li>
</ul>
<figure data-type="image" tabindex="3"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar3.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar3.png" alt="../_images/sar3.png" loading="lazy"></a></figure>
<h2 id="124-查看内存使用状况">12.4. 查看内存使用状况</h2>
<p>sar -r： 指定-r之后，可查看物理内存使用状况；</p>
<figure data-type="image" tabindex="4"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar4.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar4.png" alt="../_images/sar4.png" loading="lazy"></a></figure>
<ul>
<li>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>
<li>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>
<li>%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>
<li>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</li>
<li>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>
<li>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>
</ul>
<h2 id="125-查看页面交换发生状况">12.5. 查看页面交换发生状况</h2>
<p>sar -W：查看页面交换发生状况</p>
<p>页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用这个命令来确认是否发生了大量的交换；</p>
<figure data-type="image" tabindex="5"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar5.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar5.png" alt="../_images/sar5.png" loading="lazy"></a></figure>
<ul>
<li>pswpin/s：每秒系统换入的交换页面（swap page）数量</li>
<li>pswpout/s：每秒系统换出的交换页面（swap page）数量</li>
</ul>
<p>要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来；</p>
<ul>
<li>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</li>
<li>怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看</li>
<li>怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</li>
</ul>
<h2 id="126-安装">12.6. 安装</h2>
<ol>
<li>有的linux系统下，默认可能没有安装这个包，使用apt-get install sysstat 来安装；</li>
<li>安装完毕，将性能收集工具的开关打开： vi /etc/default/sysstat</li>
</ol>
<blockquote>
<p>设置 ENABLED=”true”</p>
</blockquote>
<ol>
<li>启动这个工具来收集系统性能数据： /etc/init.d/sysstat start</li>
</ol>
<h2 id="127-sar参数说明">12.7. sar参数说明</h2>
<ul>
<li>-A 汇总所有的报告</li>
<li>-a 报告文件读写使用情况</li>
<li>-B 报告附加的缓存的使用情况</li>
<li>-b 报告缓存的使用情况</li>
<li>-c 报告系统调用的使用情况</li>
<li>-d 报告磁盘的使用情况</li>
<li>-g 报告串口的使用情况</li>
<li>-h 报告关于buffer使用的统计数据</li>
<li>-m 报告IPC消息队列和信号量的使用情况</li>
<li>-n 报告命名cache的使用情况</li>
<li>-p 报告调页活动的使用情况</li>
<li>-q 报告运行队列和交换队列的平均长度</li>
<li>-R 报告进程的活动情况</li>
<li>-r 报告没有使用的内存页面和硬盘块</li>
<li>-u 报告CPU的利用率</li>
<li>-v 报告进程、i节点、文件和锁表状态</li>
<li>-w 报告系统交换活动状况</li>
<li>-y 报告TTY设备活动状况</li>
</ul>
<h1 id="13-readelf-elf文件格式分析">13. readelf elf文件格式分析</h1>
<p>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）；</p>
<ul>
<li>
<p><strong>ELF文件类型</strong></p>
<p>ELF(Executable and Linking Format)是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF是构成众多xNIX系统的基础之一。</p>
</li>
</ul>
<p>ELF文件有三种类型：</p>
<ol>
<li>
<ul>
<li>
<p>可重定位的对象文件(Relocatable file)</p>
<p>由汇编器汇编生成的 .o 文件</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>可执行的对象文件(Executable file)</p>
<p>可执行应用程序</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>可被共享的对象文件(Shared object file)</p>
<p>动态库文件，也即 .so 文件</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>.text section 里装载了可执行代码；</li>
<li>.data section 里面装载了被初始化的数据；</li>
<li>.bss section 里面装载了未被初始化的数据；</li>
<li>以 .rec 打头的 sections 里面装载了重定位条目；</li>
<li>.symtab 或者 .dynsym section 里面装载了符号信息；</li>
<li>.strtab 或者 .dynstr section 里面装载了字符串信息；</li>
</ul>
<h2 id="131-参数说明">13.1. 参数说明</h2>
<ul>
<li>
<p>-a –all 全部 Equivalent to: -h -l -S -s -r -d -V -A -I</p>
</li>
<li>
<p>-h –file-header 文件头 Display the ELF file header</p>
</li>
<li>
<p>-l –program-headers 程序 Display the program headers</p>
</li>
<li>
<p>–segments An alias for –program-headers</p>
</li>
<li>
<p>-S –section-headers 段头 Display the sections’ header</p>
</li>
<li>
<table>
<thead>
<tr>
<th>--sections</th>
<th>An alias for –section-headers</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>-e –headers 全部头 Equivalent to: -h -l -S</p>
</li>
<li>
<p>-s –syms 符号表 Display the symbol table</p>
</li>
<li>
<table>
<thead>
<tr>
<th>--symbols</th>
<th>An alias for –syms</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>-n –notes 内核注释 Display the core notes (if present)</p>
</li>
<li>
<p>-r –relocs 重定位 Display the relocations (if present)</p>
</li>
<li>
<p>-u –unwind Display the unwind info (if present)</p>
</li>
<li>
<p>-d –dynamic 动态段 Display the dynamic segment (if present)</p>
</li>
<li>
<p>-V –version-info 版本 Display the version sections (if present)</p>
</li>
<li>
<p>-A –arch-specific CPU构架 Display architecture specific information (if any).</p>
</li>
<li>
<p>-D –use-dynamic 动态段 Use the dynamic section info when displaying symbols</p>
</li>
<li>
<p>-x –hex-dump=<number> 显示 段内内容Dump the contents of section <number></p>
</li>
<li>
<p>-w[liaprmfFso] or</p>
</li>
<li>
<p>-I –histogram Display histogram of bucket list lengths</p>
</li>
<li>
<p>-W –wide 宽行输出 Allow output width to exceed 80 characters</p>
</li>
<li>
<p>-H –help Display this information</p>
</li>
<li>
<p>-v –version Display the version number of readelf</p>
</li>
</ul>
<h2 id="132-示例">13.2. 示例</h2>
<p>想知道一个应用程序的可运行的架构平台:</p>
<pre><code>$readelf -h main| grep Machine
</code></pre>
<p>-h选项将显示文件头的概要信息，从里面可以看到，有很多有用的信息：</p>
<pre><code>$readelf -h main
ELF Header:
Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
Class:                             ELF64
Data:                              2 s complement, little endian
Version:                           1 (current)
OS/ABI:                            UNIX - System V
ABI Version:                       0
Type:                              EXEC (Executable file)
Machine:                           Advanced Micro Devices X86-64
Version:                           0x1
Entry point address:               0x400790
Start of program headers:          64 (bytes into file)
Start of section headers:          5224 (bytes into file)
Flags:                             0x0
Size of this header:               64 (bytes)
Size of program headers:           56 (bytes)
Number of program headers:         8
Size of section headers:           64 (bytes)
Number of section headers:         29
Section header string table index: 26
</code></pre>
<p>一个编译好的应用程序，想知道其编译时是否使用了-g选项（加入调试信息）:</p>
<pre><code>$readelf -S main| grep debug
</code></pre>
<p>用-S选项是显示所有段信息；如果编译时使用了-g选项，则会有debug段;</p>
<p>查看.o文件是否编入了调试信息（编译的时候是否加了-g):</p>
<pre><code>$readelf -S Shpos.o | grep debug
</code></pre>
<h2 id="133-完整输出">13.3. 完整输出</h2>
<p>readelf输出的完整内容:</p>
<pre><code>$readelf -all a.out
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048330
  Start of program headers:          52 (bytes into file)
  Start of section headers:          4412 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         30
  Section header string table index: 27

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4
  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4
  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4
  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4
  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4
  [11] .init             PROGBITS        080482b4 0002b4 00002e 00  AX  0   0  4
  [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16
  [13] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16
  [14] .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  0   0  4
  [15] .rodata           PROGBITS        080484d8 0004d8 000011 00   A  0   0  4
  [16] .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  0   0  4
  [17] .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  0   0  4
  [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
  [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4
  [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4
  [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4
  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4
  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4
  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4
  [26] .comment          PROGBITS        00000000 001014 00002a 01  MS  0   0  1
  [27] .shstrtab         STRTAB          00000000 00103e 0000fc 00      0   0  1
  [28] .symtab           SYMTAB          00000000 0015ec 000410 10     29  45  4
  [29] .strtab           STRTAB          00000000 0019fc 0001f9 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x005e4 0x005e4 R E 0x1000
  LOAD           0x000f14 0x08049f14 0x08049f14 0x00100 0x00108 RW  0x1000
  DYNAMIC        0x000f28 0x08049f28 0x08049f28 0x000c8 0x000c8 RW  0x4
  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4
  GNU_EH_FRAME   0x0004ec 0x080484ec 0x080484ec 0x00034 0x00034 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
  GNU_RELRO      0x000f14 0x08049f14 0x08049f14 0x000ec 0x000ec R   0x1

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag .note.gnu.build-id
   06     .eh_frame_hdr
   07
   08     .ctors .dtors .jcr .dynamic .got

Dynamic section at offset 0xf28 contains 20 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x80482b4
 0x0000000d (FINI)                       0x80484bc
 0x6ffffef5 (GNU_HASH)                   0x80481ac
 0x00000005 (STRTAB)                     0x804821c
 0x00000006 (SYMTAB)                     0x80481cc
 0x0000000a (STRSZ)                      76 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x8049ff4
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x804829c
 0x00000011 (REL)                        0x8048294
 0x00000012 (RELSZ)                      8 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x8048274
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x8048268
 0x00000000 (NULL)                       0x0

Relocation section '.rel.dyn' at offset 0x294 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x29c contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a000  00000107 R_386_JUMP_SLOT   00000000   printf
0804a004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a008  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main

There are no unwind sections in this file.

Symbol table '.dynsym' contains 5 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)
     4: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used

Symbol table '.symtab' contains 65 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 08048154     0 SECTION LOCAL  DEFAULT    1
     2: 08048168     0 SECTION LOCAL  DEFAULT    2
     3: 08048188     0 SECTION LOCAL  DEFAULT    3
     4: 080481ac     0 SECTION LOCAL  DEFAULT    4
     5: 080481cc     0 SECTION LOCAL  DEFAULT    5
     6: 0804821c     0 SECTION LOCAL  DEFAULT    6
     7: 08048268     0 SECTION LOCAL  DEFAULT    7
     8: 08048274     0 SECTION LOCAL  DEFAULT    8
     9: 08048294     0 SECTION LOCAL  DEFAULT    9
    10: 0804829c     0 SECTION LOCAL  DEFAULT   10
    11: 080482b4     0 SECTION LOCAL  DEFAULT   11
    12: 080482f0     0 SECTION LOCAL  DEFAULT   12
    13: 08048330     0 SECTION LOCAL  DEFAULT   13
    14: 080484bc     0 SECTION LOCAL  DEFAULT   14
    15: 080484d8     0 SECTION LOCAL  DEFAULT   15
    16: 080484ec     0 SECTION LOCAL  DEFAULT   16
    17: 08048520     0 SECTION LOCAL  DEFAULT   17
    18: 08049f14     0 SECTION LOCAL  DEFAULT   18
    19: 08049f1c     0 SECTION LOCAL  DEFAULT   19
    20: 08049f24     0 SECTION LOCAL  DEFAULT   20
    21: 08049f28     0 SECTION LOCAL  DEFAULT   21
    22: 08049ff0     0 SECTION LOCAL  DEFAULT   22
    23: 08049ff4     0 SECTION LOCAL  DEFAULT   23
    24: 0804a00c     0 SECTION LOCAL  DEFAULT   24
    25: 0804a014     0 SECTION LOCAL  DEFAULT   25
    26: 00000000     0 SECTION LOCAL  DEFAULT   26
    27: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    28: 08049f14     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_LIST__
    29: 08049f1c     0 OBJECT  LOCAL  DEFAULT   19 __DTOR_LIST__
    30: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_LIST__
    31: 08048360     0 FUNC    LOCAL  DEFAULT   13 __do_global_dtors_aux
    32: 0804a014     1 OBJECT  LOCAL  DEFAULT   25 completed.6086
    33: 0804a018     4 OBJECT  LOCAL  DEFAULT   25 dtor_idx.6088
    34: 080483c0     0 FUNC    LOCAL  DEFAULT   13 frame_dummy
    35: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    36: 08049f18     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_END__
    37: 080485e0     0 OBJECT  LOCAL  DEFAULT   17 __FRAME_END__
    38: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_END__
    39: 08048490     0 FUNC    LOCAL  DEFAULT   13 __do_global_ctors_aux
    40: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c
    41: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_end
    42: 08049f28     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC
    43: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_start
    44: 08049ff4     0 OBJECT  LOCAL  DEFAULT   23 _GLOBAL_OFFSET_TABLE_
    45: 08048480     2 FUNC    GLOBAL DEFAULT   13 __libc_csu_fini
    46: 08048482     0 FUNC    GLOBAL HIDDEN    13 __i686.get_pc_thunk.bx
    47: 0804a00c     0 NOTYPE  WEAK   DEFAULT   24 data_start
    48: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.0
    49: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
    50: 080484bc     0 FUNC    GLOBAL DEFAULT   14 _fini
    51: 08049f20     0 OBJECT  GLOBAL HIDDEN    19 __DTOR_END__
    52: 0804a00c     0 NOTYPE  GLOBAL DEFAULT   24 __data_start
    53: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    54: 0804a010     0 OBJECT  GLOBAL HIDDEN    24 __dso_handle
    55: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used
    56: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    57: 08048410    97 FUNC    GLOBAL DEFAULT   13 __libc_csu_init
    58: 0804a01c     0 NOTYPE  GLOBAL DEFAULT  ABS _end
    59: 08048330     0 FUNC    GLOBAL DEFAULT   13 _start
    60: 080484d8     4 OBJECT  GLOBAL DEFAULT   15 _fp_hw
    61: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
    62: 080483e4    40 FUNC    GLOBAL DEFAULT   13 main
    63: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
    64: 080482b4     0 FUNC    GLOBAL DEFAULT   11 _init

Histogram for `.gnu.hash' bucket list length (total of 2 buckets):
 Length  Number     % of total  Coverage
      0  1          ( 50.0%)
      1  1          ( 50.0%)    100.0%

Version symbols section '.gnu.version' contains 5 entries:
 Addr: 0000000008048268  Offset: 0x000268  Link: 5 (.dynsym)
  000:   0 (*local*)       2 (GLIBC_2.0)     0 (*local*)       2 (GLIBC_2.0)
  004:   1 (*global*)

Version needs section '.gnu.version_r' contains 1 entries:
 Addr: 0x0000000008048274  Offset: 0x000274  Link: 6 (.dynstr)
  000000: Version: 1  File: libc.so.6  Cnt: 1
  0x0010:   Name: GLIBC_2.0  Flags: none  Version: 2

Notes at offset 0x00000168 with length 0x00000020:
  Owner                 Data size   Description
  GNU                  0x00000010   NT_GNU_ABI_TAG (ABI version tag)
    OS: Linux, ABI: 2.6.15

Notes at offset 0x00000188 with length 0x00000024:
  Owner                 Data size   Description
  GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: 17fb9651029b6a8543bfafec9eea23bd16454e65
</code></pre>
<h1 id="14-objdump-二进制文件分析">14. objdump 二进制文件分析</h1>
<p>objdump工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。</p>
<h2 id="141-常用参数说明">14.1. 常用参数说明</h2>
<ul>
<li>-f 显示文件头信息</li>
<li>-D 反汇编所有section (-d反汇编特定section)</li>
<li>-h 显示目标文件各个section的头部摘要信息</li>
<li>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。</li>
<li>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li>
<li>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。</li>
<li>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li>
<li>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。</li>
<li>-t 显示文件的符号表入口。类似于nm -s提供的信息</li>
</ul>
<h2 id="142-示例">14.2. 示例</h2>
<p>查看本机目标结构（使用大端还是小端存储）:</p>
<pre><code>$objdump -i
</code></pre>
<p>反汇编程序:</p>
<pre><code>$objdump -d main.o
</code></pre>
<p>显示符号表入口:</p>
<pre><code>$objdump  -t main.o
</code></pre>
<p>希望显示可用的简洁帮助信息，直接输入objdump即可；（objdump -H)</p>
<h1 id="15-nm-目标文件格式分析">15. nm 目标文件格式分析</h1>
<p>nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。如果文件没有包含符号信息，nm 命令报告该情况，但不把它解释为出错条件。 nm 命令缺省情况下报告十进制符号表示法下的数字值。</p>
<pre><code>$nm myProgrammer
08049f28 d _DYNAMIC
08049ff4 d _GLOBAL_OFFSET_TABLE_
080484dc R _IO_stdin_used
         w _Jv_RegisterClasses
08049f18 d __CTOR_END__
08049f14 d __CTOR_LIST__
08049f20 D __DTOR_END__
08049f1c d __DTOR_LIST__
080485e0 r __FRAME_END__
08049f24 d __JCR_END__
08049f24 d __JCR_LIST__
0804a014 A __bss_start
0804a00c D __data_start
08048490 t __do_global_ctors_aux
08048360 t __do_global_dtors_aux
0804a010 D __dso_handle
         w __gmon_start__
08048482 T __i686.get_pc_thunk.bx
08049f14 d __init_array_end
08049f14 d __init_array_start
08048480 T __libc_csu_fini
08048410 T __libc_csu_init
         U __libc_start_main@@GLIBC_2.0
0804a014 A _edata
0804a01c A _end
080484bc T _fini
080484d8 R _fp_hw
080482b4 T _init
08048330 T _start
0804a014 b completed.6086
0804a00c W data_start
0804a018 b dtor_idx.6088
080483c0 t frame_dummy
080483e4 T main
         U printf@@GLIBC_2.0
</code></pre>
<p>这些包含可执行代码的段称为正文段。同样地，数据段包含了不可执行的信息或数据。另一种类型的段，称为 BSS 段，它包含以符号数据开头的块。对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。</p>
<p>可以将目标文件中所包含的不同的部分划分为段。段可以包含可执行代码、符号名称、初始数据值和许多其他类型的数据。有关这些类型的数据的详细信息，可以阅读 UNIX 中 nm 的 man 页面，其中按照该命令输出中的字符编码分别对每种类型进行了描述。</p>
<h2 id="151-选项说明">15.1. 选项说明</h2>
<ul>
<li>-a或–debug-syms：显示所有的符号，包括debugger-only symbols。</li>
<li>-B：等同于–format=bsd，用来兼容MIPS的nm。</li>
<li>-C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</li>
<li>–no-demangle：默认的选项，不需要将低级符号名解析成用户级名。</li>
<li>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</li>
<li>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</li>
<li>-g或–extern-only：仅显示外部符号。</li>
<li>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</li>
<li>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</li>
<li>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</li>
<li>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</li>
<li>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</li>
<li>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</li>
<li>–target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</li>
<li>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</li>
<li>–defined-only:仅显示定义的符号。</li>
<li>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。</li>
<li>-V或–version：显示nm的版本号。</li>
<li>–help：显示nm的选项。</li>
</ul>
<h2 id="152-符号说明">15.2. 符号说明</h2>
<p>对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的。</p>
<ul>
<li>
<p>A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</p>
</li>
<li>
<p>B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。</p>
</li>
<li>
<p>C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。</p>
</li>
<li>
<ul>
<li>
<p>D 该符号位于初始化数据段中。一般来说，分配到data section中。</p>
<p>例如：定义全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，会分配到初始化数据段中。</p>
</li>
</ul>
</li>
<li>
<p>G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。</p>
</li>
<li>
<p>I 该符号是对另一个符号的间接引用。</p>
</li>
<li>
<p>N 该符号是一个debugging符号。</p>
</li>
<li>
<ul>
<li>
<p>R 该符号位于只读数据区。</p>
<p>例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。值得注意的是，如果在一个函数中定义const char <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html#id4">*</a>test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。</p>
</li>
</ul>
</li>
<li>
<p>S 符号位于非初始化数据区，用于small object。</p>
</li>
<li>
<p>T 该符号位于代码区text section。</p>
</li>
<li>
<ul>
<li>
<p>U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。</p>
<p>例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。</p>
</li>
</ul>
</li>
<li>
<p>V 该符号是一个weak object。</p>
</li>
<li>
<p>W The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</p>
</li>
<li>
<p>? 该符号类型没有定义</p>
</li>
</ul>
<p><em>库或对象名</em> 如果您指定了 -A 选项，则 nm 命令只报告与该文件有关的或者库或者对象名。</p>
<h2 id="153-示例">15.3. 示例</h2>
<ol>
<li>寻找特殊标识</li>
</ol>
<p>有时会碰到一个编译了但没有链接的代码，那是因为它缺失了标识符；这种情况，可以用nm和objdump、readelf命令来查看程序的符号表；所有这些命令做的工作基本一样；</p>
<p>比如连接器报错有未定义的标识符；大多数情况下，会发生在库的缺失或企图链接一个错误版本的库的时候；浏览目标代码来寻找一个特殊标识符的引用:</p>
<pre><code>nm -uCA *.o | grep foo
</code></pre>
<p>-u选项限制了每个目标文件中未定义标识符的输出。-A选项用于显示每个标识符的文件名信息；对于C++代码，常用的还有-C选项，它也为解码这些标识符；</p>
<p>注解</p>
<p>objdump、readld命令可以完成同样的任务。等效命令为： $objdump -t $readelf -s</p>
<ol>
<li>
<p>列出 a.out 对象文件的静态和外部符:</p>
<pre><code>$nm -e a.out
</code></pre>
</li>
<li>
<p>以十六进制显示符号大小和值并且按值排序符号:</p>
<pre><code>$nm -xv a.out
</code></pre>
</li>
<li>
<p>显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象:</p>
<pre><code>$nm -X64 /usr/lib/libc.a
</code></pre>
</li>
</ol>
<h1 id="16-size-查看程序内存映像大小">16. size 查看程序内存映像大小</h1>
<p>作用：查看程序被映射到内存中的映像所占用的大小信息。</p>
<p>程序映射到内存中，从低地址到高地址依次为下列段:</p>
<ul>
<li>代码段： 只读，可共享; 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
<li>数据段： 储存已被初始化了的静态数据。数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li>
<li>BSS 段：未初始化的数据段. BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配。</li>
<li>堆（heap ）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>
<li>栈(stack) ：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{} ”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
</ul>
<p>另外, 在高地址还储存了命令行参数及环境变量.</p>
<p>因为内存程序映像中的各段可能位于不同的地址空间中, 它们不一定位于连续的内存块中. 操作系统将程序映像映射到地址空间时, 通常将内存程序映像划分为大小相同的块(也就是page, 页). 只有该页被引用时, 它才被加载到内存中. 不过对于程序员来说, 可以视内存程序映像在逻辑上是连续的.</p>
<pre><code>/opt/app/todeav1/colin/tests#size main
text    data     bss     dec     hex filename
1259     540      16    1815     717 main
</code></pre>
]]></summary>
        <content type="html"><![CDATA[<h1 id="1-gdb-调试利器">1. gdb 调试利器</h1>
<p>GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c++程序员，gdb是必不可少的工具；</p>
<h2 id="11-启动gdb">1.1. 启动gdb</h2>
<p>对C/C++程序的调试，需要在编译前就加上-g选项:</p>
<pre><code>$g++ -g hello.cpp -o hello
</code></pre>
<p>调试可执行文件:</p>
<pre><code>$gdb &lt;program&gt;
</code></pre>
<p>program也就是你的执行文件，一般在当前目录下。</p>
<p>调试core文件(core是程序非法执行后core dump后产生的文件):</p>
<pre><code>$gdb &lt;program&gt; &lt;core dump file&gt;
$gdb program core.11127
</code></pre>
<p>调试服务程序:</p>
<pre><code>$gdb &lt;program&gt; &lt;PID&gt;
$gdb hello 11127
</code></pre>
<p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p>
<h2 id="12-gdb交互命令">1.2. gdb交互命令</h2>
<p>启动gdb后，进入到交互模式，通过以下命令完成对程序的调试；注意高频使用的命令一般都会有缩写，熟练使用这些缩写命令能提高调试的效率；</p>
<h3 id="运行">运行</h3>
<ul>
<li>run：简记为 r ，其作用是运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。</li>
<li>continue （简写c ）：继续执行，到下一个断点处（或运行结束）</li>
<li>next：（简写 n），单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。</li>
<li>step （简写s）：单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</li>
<li>until：当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</li>
<li>until+行号： 运行至某行，不仅仅用来跳出循环</li>
<li>finish： 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。</li>
<li>call 函数(参数)：调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)</li>
<li>quit：简记为 q ，退出gdb</li>
</ul>
<h3 id="设置断点">设置断点</h3>
<ul>
<li>
<ul>
<li>
<p>break n （简写b n）:在第n行处设置断点</p>
<p>（可以带上代码路径和代码名称： b OAGUPDATE.cpp:578）</p>
</li>
</ul>
</li>
<li>
<p>b fn1 if a＞b：条件断点设置</p>
</li>
<li>
<p>break func（break缩写为b）：在函数func()的入口处设置断点，如：break cb_button</p>
</li>
<li>
<p>delete 断点号n：删除第n个断点</p>
</li>
<li>
<p>disable 断点号n：暂停第n个断点</p>
</li>
<li>
<p>enable 断点号n：开启第n个断点</p>
</li>
<li>
<p>clear 行号n：清除第n行的断点</p>
</li>
<li>
<p>info b （info breakpoints） ：显示当前程序的断点设置情况</p>
</li>
<li>
<p>delete breakpoints：清除所有断点：</p>
</li>
</ul>
<h3 id="查看源代码">查看源代码</h3>
<ul>
<li>list ：简记为 l ，其作用就是列出程序的源代码，默认每次显示10行。</li>
<li>list 行号：将显示当前文件以“行号”为中心的前后10行代码，如：list 12</li>
<li>list 函数名：将显示“函数名”所在函数的源代码，如：list main</li>
<li>list ：不带参数，将接着上一次 list 命令的，输出下边的内容。</li>
</ul>
<h3 id="打印表达式">打印表达式</h3>
<ul>
<li>print 表达式：简记为 p ，其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。</li>
<li>print a：将显示整数 a 的值</li>
<li>print ++a：将把 a 中的值加1,并显示出来</li>
<li>print name：将显示字符串 name 的值</li>
<li>print gdb_test(22)：将以整数22作为参数调用 gdb_test() 函数</li>
<li>print gdb_test(a)：将以变量 a 作为参数调用 gdb_test() 函数</li>
<li>display 表达式：在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a</li>
<li>watch 表达式：设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a</li>
<li>whatis ：查询变量或函数</li>
<li>info function： 查询函数</li>
<li>扩展info locals： 显示当前堆栈页的所有变量</li>
</ul>
<h3 id="查询运行信息">查询运行信息</h3>
<ul>
<li>where/bt ：当前运行的堆栈列表；</li>
<li>bt backtrace 显示当前调用堆栈</li>
<li>up/down 改变堆栈显示的深度</li>
<li>set args 参数:指定运行时的参数</li>
<li>show args：查看设置好的参数</li>
<li>info program： 来查看程序的是否在运行，进程号，被暂停的原因。</li>
</ul>
<h3 id="分割窗口">分割窗口</h3>
<ul>
<li>layout：用于分割窗口，可以一边查看代码，一边测试：</li>
<li>layout src：显示源代码窗口</li>
<li>layout asm：显示反汇编窗口</li>
<li>layout regs：显示源代码/反汇编和CPU寄存器窗口</li>
<li>layout split：显示源代码和反汇编窗口</li>
<li>Ctrl + L：刷新窗口</li>
</ul>
<p>注解</p>
<p>交互模式下直接回车的作用是重复上一指令，对于单步调试非常方便；</p>
<h2 id="13-更强大的工具">1.3. 更强大的工具</h2>
<h3 id="cgdb">cgdb</h3>
<p>cgdb可以看作gdb的界面增强版,用来替代gdb的 gdb -tui。cgdb主要功能是在调试时进行代码的同步显示，这无疑增加了调试的方便性，提高了调试效率。界面类似vi，符合unix/linux下开发人员习惯;如果熟悉gdb和vi，几乎可以立即使用cgdb。</p>
<h1 id="2-ldd-查看程序依赖库">2. ldd 查看程序依赖库</h1>
<ul>
<li>
<p>ldd</p>
<p>作用：用来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。</p>
</li>
</ul>
<p>示例：查看test程序运行所依赖的库:</p>
<pre><code>/opt/app/todeav1/test$ldd test
libstdc++.so.6 =&gt; /usr/lib64/libstdc++.so.6 (0x00000039a7e00000)
libm.so.6 =&gt; /lib64/libm.so.6 (0x0000003996400000)
libgcc_s.so.1 =&gt; /lib64/libgcc_s.so.1 (0x00000039a5600000)
libc.so.6 =&gt; /lib64/libc.so.6 (0x0000003995800000)
/lib64/ld-linux-x86-64.so.2 (0x0000003995400000)
</code></pre>
<ul>
<li>第一列：程序需要依赖什么库</li>
<li>第二列: 系统提供的与程序需要的库所对应的库</li>
<li>第三列：库加载的开始地址</li>
</ul>
<p>通过上面的信息，我们可以得到以下几个信息：</p>
<ol>
<li>通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配</li>
<li>通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置</li>
</ol>
<p>如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在；</p>
<p>注解</p>
<p>原理： ldd不是个可执行程式，而只是个shell脚本； ldd显示可执行模块的dependency的工作原理，其实质是通过ld-linux.so（elf动态库的装载器）来实现的。ld-linux.so模块会先于executable模块程式工作，并获得控制权，因此当上述的那些环境变量被设置时，ld-linux.so选择了显示可执行模块的dependency。</p>
<h1 id="3-lsof-一切皆文件">3. lsof 一切皆文件</h1>
<p>lsof（list open files）是一个查看当前系统文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。</p>
<p>lsof打开的文件可以是：</p>
<ol>
<li>普通文件</li>
<li>目录</li>
<li>网络文件系统的文件</li>
<li>字符或设备文件</li>
<li>(函数)共享库</li>
<li>管道，命名管道</li>
<li>符号链接</li>
<li>网络文件（例如：NFS file、网络socket，unix域名socket）</li>
<li>还有其它类型的文件，等等</li>
</ol>
<h2 id="31-命令参数">3.1. 命令参数</h2>
<ul>
<li>-a 列出打开文件存在的进程</li>
<li>-c&lt;进程名&gt; 列出指定进程所打开的文件</li>
<li>-g 列出GID号进程详情</li>
<li>-d&lt;文件号&gt; 列出占用该文件号的进程</li>
<li>+d&lt;目录&gt; 列出目录下被打开的文件</li>
<li>+D&lt;目录&gt; 递归列出目录下被打开的文件</li>
<li>-n&lt;目录&gt; 列出使用NFS的文件</li>
<li>-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</li>
<li>-p&lt;进程号&gt; 列出指定进程号所打开的文件</li>
<li>-u 列出UID号进程详情</li>
<li>-h 显示帮助信息</li>
<li>-v 显示版本信息</li>
</ul>
<h2 id="32-使用实例">3.2. 使用实例</h2>
<h3 id="实例1无任何参数">实例1：无任何参数</h3>
<pre><code>$lsof| more
COMMAND     PID      USER   FD      TYPE             DEVICE SIZE/OFF       NODE NAME
init          1      root  cwd       DIR              253,0     4096          2 /
init          1      root  rtd       DIR              253,0     4096          2 /
init          1      root  txt       REG              253,0   150352    1310795 /sbin/init
init          1      root  mem       REG              253,0    65928    5505054 /lib64/libnss_files-2.12.so
init          1      root  mem       REG              253,0  1918016    5521405 /lib64/libc-2.12.so
init          1      root  mem       REG              253,0    93224    5521440 /lib64/libgcc_s-4.4.6-20120305.so.1
init          1      root  mem       REG              253,0    47064    5521407 /lib64/librt-2.12.so
init          1      root  mem       REG              253,0   145720    5521406 /lib64/libpthread-2.12.so
...
</code></pre>
<p>说明：</p>
<p>lsof输出各列信息的意义如下：</p>
<ul>
<li>
<p>COMMAND：进程的名称</p>
</li>
<li>
<p>PID：进程标识符</p>
</li>
<li>
<p>PPID：父进程标识符（需要指定-R参数）</p>
</li>
<li>
<p>USER：进程所有者</p>
</li>
<li>
<p>PGID：进程所属组</p>
</li>
<li>
<p>FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等:</p>
<pre><code>（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改
（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序
（3）lnn：library references (AIX);
（4）er：FD information error (see NAME column);
（5）jld：jail directory (FreeBSD);
（6）ltx：shared library text (code and data);
（7）mxx ：hex memory-mapped type number xx.
（8）m86：DOS Merge mapped file;
（9）mem：memory-mapped file;
（10）mmap：memory-mapped device;
（11）pd：parent directory;
（12）rtd：root directory;
（13）tr：kernel trace file (OpenBSD);
（14）v86  VP/ix mapped file;
（15）0：表示标准输入
（16）1：表示标准输出
（17）2：表示标准错误
一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等
（1）u：表示该文件被打开并处于读取/写入模式
（2）r：表示该文件被打开并处于只读模式
（3）w：表示该文件被打开并处于
（4）空格：表示该文件的状态模式为unknow，且没有锁定
（5）-：表示该文件的状态模式为unknow，且被锁定
同时在文件状态模式后面，还跟着相关的锁
（1）N：for a Solaris NFS lock of unknown type;
（2）r：for read lock on part of the file;
（3）R：for a read lock on the entire file;
（4）w：for a write lock on part of the file;（文件的部分写锁）
（5）W：for a write lock on the entire file;（整个文件的写锁）
（6）u：for a read and write lock of any length;
（7）U：for a lock of unknown type;
（8）x：for an SCO OpenServer Xenix lock on part      of the file;
（9）X：for an SCO OpenServer Xenix lock on the      entire file;
（10）space：if there is no lock.
</code></pre>
</li>
<li>
<p>TYPE：文件类型，如DIR、REG等，常见的文件类型:</p>
<pre><code>（1）DIR：表示目录
（2）CHR：表示字符类型
（3）BLK：块设备类型
（4）UNIX： UNIX 域套接字
（5）FIFO：先进先出 (FIFO) 队列
（6）IPv4：网际协议 (IP) 套接字
</code></pre>
</li>
<li>
<p>DEVICE：指定磁盘的名称</p>
</li>
<li>
<p>SIZE：文件的大小</p>
</li>
<li>
<p>NODE：索引节点（文件在磁盘上的标识）</p>
</li>
<li>
<p>NAME：打开文件的确切名称</p>
</li>
</ul>
<h3 id="实例2查找某个文件相关的进程">实例2：查找某个文件相关的进程</h3>
<pre><code>$lsof /bin/bash
COMMAND     PID USER  FD   TYPE DEVICE SIZE/OFF    NODE NAME
mysqld_sa  2169 root txt    REG  253,0   938736 4587562 /bin/bash
ksmtuned   2334 root txt    REG  253,0   938736 4587562 /bin/bash
bash      20121 root txt    REG  253,0   938736 4587562 /bin/bash
</code></pre>
<h3 id="实例3列出某个用户打开的文件信息">实例3：列出某个用户打开的文件信息</h3>
<pre><code>   $lsof -u username

-u 选项，u是user的缩写
</code></pre>
<h3 id="实例4列出某个程序进程所打开的文件信息">实例4：列出某个程序进程所打开的文件信息</h3>
<pre><code>$lsof -c mysql
</code></pre>
<p>-c 选项将会列出所有以mysql这个进程开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符；</p>
<h3 id="实例5列出某个用户以及某个进程所打开的文件信息">实例5：列出某个用户以及某个进程所打开的文件信息</h3>
<pre><code>$lsof  -u test -c mysql
</code></pre>
<h3 id="实例6通过某个进程号显示该进程打开的文件">实例6：通过某个进程号显示该进程打开的文件</h3>
<pre><code>$lsof -p 11968
</code></pre>
<h3 id="实例7列出所有的网络连接">实例7：列出所有的网络连接</h3>
<pre><code>$lsof -i
</code></pre>
<h3 id="实例8列出所有tcp-网络连接信息">实例8：列出所有tcp 网络连接信息</h3>
<pre><code>$lsof -i tcp

$lsof -n -i tcp
COMMAND     PID  USER   FD   TYPE  DEVICE SIZE/OFF NODE NAME
svnserve  11552 weber    3u  IPv4 3799399      0t0  TCP *:svn (LISTEN)
redis-ser 25501 weber    4u  IPv4  113150      0t0  TCP 127.0.0.1:6379 (LISTEN)
</code></pre>
<h3 id="实例9列出谁在使用某个端口">实例9：列出谁在使用某个端口</h3>
<pre><code>$lsof -i :3306
</code></pre>
<h3 id="实例10列出某个用户的所有活跃的网络端口">实例10：列出某个用户的所有活跃的网络端口</h3>
<pre><code>$lsof -a -u test -i
</code></pre>
<h3 id="实例11根据文件描述列出对应的文件信息">实例11：根据文件描述列出对应的文件信息</h3>
<pre><code>$lsof -d description(like 2)
</code></pre>
<p>示例:</p>
<pre><code>$lsof -d 3 | grep PARSER1
tail      6499 tde    3r   REG    253,3   4514722     417798 /opt/applog/open/log/HOSTPARSER1_ERROR_141217.log.001
</code></pre>
<p>说明： 0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</p>
<h3 id="实例12列出被进程号为1234的进程所打开的所有ipv4-network-files">实例12：列出被进程号为1234的进程所打开的所有IPV4 network files</h3>
<pre><code>$lsof -i 4 -a -p 1234
</code></pre>
<h3 id="实例13列出目前连接主机nf5260i5-td上端口为202180相关的所有文件信息且每隔3秒重复执行">实例13：列出目前连接主机nf5260i5-td上端口为：20，21，80相关的所有文件信息，且每隔3秒重复执行</h3>
<pre><code>lsof -i @nf5260i5-td:20,21,80 -r 3
</code></pre>
<h1 id="4-ps-进程查看器">4. ps 进程查看器</h1>
<p>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p>
<p>要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p>
<p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/top.html#top">top linux下的任务管理器</a> 工具。</p>
<p>注：kill 命令用于杀死进程。</p>
<p>linux上进程有5种状态:</p>
<ol>
<li>运行(正在运行或在运行队列中等待)</li>
<li>中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</li>
<li>不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</li>
<li>僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</li>
<li>停止(进程收到SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU信号后停止运行运行)</li>
</ol>
<p>ps工具标识进程的5种状态码:</p>
<ul>
<li>D 不可中断 uninterruptible sleep (usually IO)</li>
<li>R 运行 runnable (on run queue)</li>
<li>S 中断 sleeping</li>
<li>T 停止 traced or stopped</li>
<li>Z 僵死 a defunct (”zombie”) process</li>
</ul>
<h2 id="41-命令参数">4.1. 命令参数</h2>
<ul>
<li>a 显示所有进程</li>
<li>-a 显示同一终端下的所有程序</li>
<li>-A 显示所有进程</li>
<li>c 显示进程的真实名称</li>
<li>-N 反向选择</li>
<li>-e 等于“-A”</li>
<li>e 显示环境变量</li>
<li>f 显示程序间的关系</li>
<li>-H 显示树状结构</li>
<li>r 显示当前终端的进程</li>
<li>T 显示当前终端的所有程序</li>
<li>u 指定用户的所有进程</li>
<li>-au 显示较详细的资讯</li>
<li>-aux 显示所有包含其他使用者的行程</li>
<li>-C&lt;命令&gt; 列出指定命令的状况</li>
<li>–lines&lt;行数&gt; 每页显示的行数</li>
<li>–width&lt;字符数&gt; 每页显示的字符数</li>
<li>–help 显示帮助信息</li>
<li>–version 显示版本显示</li>
</ul>
<h2 id="42-输出列的含义">4.2. 输出列的含义</h2>
<ul>
<li>F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</li>
<li>S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</li>
<li>UID 程序被该 UID 所拥有</li>
<li>PID 进程的ID</li>
<li>PPID 则是其上级父程序的ID</li>
<li>C CPU 使用的资源百分比</li>
<li>PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</li>
<li>NI 这个是 Nice 值，在下一小节我们会持续介绍</li>
<li>ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个 running的程序，一般就是 “-“</li>
<li>SZ 使用掉的内存大小</li>
<li>WCHAN 目前这个程序是否正在运作当中，若为 - 表示正在运作</li>
<li>TTY 登入者的终端机位置</li>
<li>TIME 使用掉的 CPU 时间。</li>
<li>CMD 所下达的指令为何</li>
</ul>
<h2 id="43-使用实例">4.3. 使用实例</h2>
<h3 id="实例1显示所有进程信息">实例1：显示所有进程信息</h3>
<pre><code>[root@localhost test6]# ps -A
PID TTY          TIME CMD
1 ?        00:00:00 init
2 ?        00:00:01 migration/0
3 ?        00:00:00 ksoftirqd/0
4 ?        00:00:01 migration/1
5 ?        00:00:00 ksoftirqd/1
6 ?        00:29:57 events/0
7 ?        00:00:00 events/1
8 ?        00:00:00 khelper
49 ?        00:00:00 kthread
54 ?        00:00:00 kblockd/0
55 ?        00:00:00 kblockd/1
56 ?        00:00:00 kacpid
217 ?        00:00:00 cqueue/0
……省略部分结果
</code></pre>
<h3 id="实例2显示指定用户信息">实例2：显示指定用户信息</h3>
<pre><code>[root@localhost test6]# ps -u root
PID TTY          TIME CMD
1 ?        00:00:00 init
2 ?        00:00:01 migration/0
3 ?        00:00:00 ksoftirqd/0
4 ?        00:00:01 migration/1
5 ?        00:00:00 ksoftirqd/1
6 ?        00:29:57 events/0
7 ?        00:00:00 events/1
8 ?        00:00:00 khelper
49 ?        00:00:00 kthread
54 ?        00:00:00 kblockd/0
55 ?        00:00:00 kblockd/1
56 ?        00:00:00 kacpid
……省略部分结果
</code></pre>
<h3 id="实例3显示所有进程信息连同命令行">实例3：显示所有进程信息，连同命令行</h3>
<pre><code>[root@localhost test6]# ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD
root         1     0  0 Nov02 ?        00:00:00 init [3]
root         2     1  0 Nov02 ?        00:00:01 [migration/0]
root         3     1  0 Nov02 ?        00:00:00 [ksoftirqd/0]
root         4     1  0 Nov02 ?        00:00:01 [migration/1]
root         5     1  0 Nov02 ?        00:00:00 [ksoftirqd/1]
root         6     1  0 Nov02 ?        00:29:57 [events/0]
root         7     1  0 Nov02 ?        00:00:00 [events/1]
root         8     1  0 Nov02 ?        00:00:00 [khelper]
root        49     1  0 Nov02 ?        00:00:00 [kthread]
root        54    49  0 Nov02 ?        00:00:00 [kblockd/0]
root        55    49  0 Nov02 ?        00:00:00 [kblockd/1]
root        56    49  0 Nov02 ?        00:00:00 [kacpid]
</code></pre>
<h3 id="实例4-ps-与grep-组合使用查找特定进程">实例4： ps 与grep 组合使用，查找特定进程</h3>
<pre><code>[root@localhost test6]# ps -ef|grep ssh
root      2720     1  0 Nov02 ?        00:00:00 /usr/sbin/sshd
root     17394  2720  0 14:58 ?        00:00:00 sshd: root@pts/0
root     17465 17398  0 15:57 pts/0    00:00:00 grep ssh
</code></pre>
<h3 id="实例5将与这次登入的-pid-与相关信息列示出来">实例5：将与这次登入的 PID 与相关信息列示出来</h3>
<pre><code>[root@localhost test6]# ps -l
F S   UID   PID  PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
4 S     0 17398 17394  0  75   0 - 16543 wait   pts/0    00:00:00 bash
4 R     0 17469 17398  0  77   0 - 15877 -      pts/0    00:00:00 ps
</code></pre>
<h3 id="实例6列出目前所有的正在内存中的程序">实例6：列出目前所有的正在内存中的程序</h3>
<pre><code>[root@localhost test6]# ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.0  10368   676 ?        Ss   Nov02   0:00 init [3]
root         2  0.0  0.0      0     0 ?        S&lt;   Nov02   0:01 [migration/0]
root         3  0.0  0.0      0     0 ?        SN   Nov02   0:00 [ksoftirqd/0]
root         4  0.0  0.0      0     0 ?        S&lt;   Nov02   0:01 [migration/1]
root         5  0.0  0.0      0     0 ?        SN   Nov02   0:00 [ksoftirqd/1]
root         6  0.0  0.0      0     0 ?        S&lt;   Nov02  29:57 [events/0]
root         7  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [events/1]
root         8  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [khelper]
root        49  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kthread]
root        54  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kblockd/0]
root        55  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kblockd/1]
root        56  0.0  0.0      0     0 ?        S&lt;   Nov02   0:00 [kacpid]
</code></pre>
<h1 id="5-pstack-跟踪进程栈">5. pstack 跟踪进程栈</h1>
<p>此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。请参见 proc(1) 手册页。</p>
<p>这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p>
<p>示例：查看bash程序进程栈:</p>
<pre><code>/opt/app/tdev1$ps -fe| grep bash
tdev1   7013  7012  0 19:42 pts/1    00:00:00 -bash
tdev1  11402 11401  0 20:31 pts/2    00:00:00 -bash
tdev1  11474 11402  0 20:32 pts/2    00:00:00 grep bash
/opt/app/tdev1$pstack 7013
#0  0x00000039958c5620 in __read_nocancel () from /lib64/libc.so.6
#1  0x000000000047dafe in rl_getc ()
#2  0x000000000047def6 in rl_read_key ()
#3  0x000000000046d0f5 in readline_internal_char ()
#4  0x000000000046d4e5 in readline ()
#5  0x00000000004213cf in ?? ()
#6  0x000000000041d685 in ?? ()
#7  0x000000000041e89e in ?? ()
#8  0x00000000004218dc in yyparse ()
#9  0x000000000041b507 in parse_command ()
#10 0x000000000041b5c6 in read_command ()
#11 0x000000000041b74e in reader_loop ()
#12 0x000000000041b2aa in main ()
</code></pre>
<h1 id="6-strace-跟踪进程中的系统调用">6. strace 跟踪进程中的系统调用</h1>
<p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p>
<h2 id="61-输出参数含义">6.1. 输出参数含义</h2>
<p>每一行都是一条系统调用，等号左边是系统调用的函数名及其参数，右边是该调用的返回值。 strace 显示这些调用的参数并返回符号形式的值。strace 从内核接收信息，而且不需要以任何特殊的方式来构建内核。</p>
<pre><code>$strace cat /dev/null
execve(&quot;/bin/cat&quot;, [&quot;cat&quot;, &quot;/dev/null&quot;], [/* 22 vars */]) = 0
brk(0)                                  = 0xab1000
access(&quot;/etc/ld.so.nohwcap&quot;, F_OK)      = -1 ENOENT (No such file or directory)
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f29379a7000
access(&quot;/etc/ld.so.preload&quot;, R_OK)      = -1 ENOENT (No such file or directory)
...
</code></pre>
<h2 id="62-参数">6.2. 参数</h2>
<pre><code>-c 统计每一系统调用的所执行的时间,次数和出错的次数等.
-d 输出strace关于标准错误的调试信息.
-f 跟踪由fork调用所产生的子进程.
-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号.
-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪.
-h 输出简要的帮助信息.
-i 输出系统调用的入口指针.
-q 禁止输出关于脱离的消息.
-r 打印出相对时间关于,,每一个系统调用.
-t 在输出中的每一行前加上时间信息.
-tt 在输出中的每一行前加上时间信息,微秒级.
-ttt 微秒级输出,以秒了表示时间.
-T 显示每一调用所耗的时间.
-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出.
-V 输出strace的版本信息.
-x 以十六进制形式输出非标准字符串
-xx 所有字符串以十六进制形式输出.
-a column
设置返回值的输出位置.默认 为40.
-e expr
指定一个表达式,用来控制如何跟踪.格式如下:
[qualifier=][!]value1[,value2]...
qualifier只能是 trace,abbrev,verbose,raw,signal,read,write其中之一.value是用来限定的符号或数字.默认的 qualifier是 trace.感叹号是否定符号.例如:
-eopen等价于 -e trace=open,表示只跟踪open调用.而-etrace!=open表示跟踪除了open以外的其他调用.有两个特殊的符号 all 和 none.
注意有些shell使用!来执行历史记录里的命令,所以要使用\\.
-e trace=set
只跟踪指定的系统 调用.例如:-e trace=open,close,rean,write表示只跟踪这四个系统调用.默认的为set=all.
-e trace=file
只跟踪有关文件操作的系统调用.
-e trace=process
只跟踪有关进程控制的系统调用.
-e trace=network
跟踪与网络有关的所有系统调用.
-e strace=signal
跟踪所有与系统信号有关的 系统调用
-e trace=ipc
跟踪所有与进程通讯有关的系统调用
-e abbrev=set
设定 strace输出的系统调用的结果集.-v 等与 abbrev=none.默认为abbrev=all.
-e raw=set
将指 定的系统调用的参数以十六进制显示.
-e signal=set
指定跟踪的系统信号.默认为all.如 signal=!SIGIO(或者signal=!io),表示不跟踪SIGIO信号.
-e read=set
输出从指定文件中读出 的数据.例如:
-e read=3,5
-e write=set
输出写入到指定文件中的数据.
-o filename
将strace的输出写入文件filename
-p pid
跟踪指定的进程pid.
-s strsize
指定输出的字符串的最大长度.默认为32.文件名一直全部输出.
-u username
以username 的UID和GID执行被跟踪的命令
</code></pre>
<h2 id="63-命令实例">6.3. 命令实例</h2>
<h3 id="跟踪可执行程序">跟踪可执行程序</h3>
<pre><code>strace -f -F -o ~/straceout.txt myserver
</code></pre>
<p>-f -F选项告诉strace同时跟踪fork和vfork出来的进程，-o选项把所有strace输出写到~/straceout.txt里 面，myserver是要启动和调试的程序。</p>
<h3 id="跟踪服务程序">跟踪服务程序</h3>
<pre><code>strace -o output.txt -T -tt -e trace=all -p 28979
</code></pre>
<p>跟踪28979进程的所有系统调用（-e trace=all），并统计系统调用的花费时间，以及开始时间（并以可视化的时分秒格式显示），最后将记录结果存在output.txt文件里面。</p>
<h1 id="7-ipcs-查询进程间通信状态">7. ipcs 查询进程间通信状态</h1>
<p>ipcs是Linux下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息。对于程序员非常有用，普通的系统管理员一般用不到此指令。</p>
<h2 id="71-ipc资源查询">7.1. IPC资源查询</h2>
<h3 id="查看系统使用的ipc资源">查看系统使用的IPC资源</h3>
<pre><code>$ipcs

------ Shared Memory Segments --------
key        shmid      owner      perms      bytes      nattch     status

------ Semaphore Arrays --------
key        semid      owner      perms      nsems
0x00000000 229376     weber      600        1

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
</code></pre>
<p>分别查询IPC资源:</p>
<pre><code>$ipcs -m 查看系统使用的IPC共享内存资源
$ipcs -q 查看系统使用的IPC队列资源
$ipcs -s 查看系统使用的IPC信号量资源
</code></pre>
<h3 id="查看ipc资源被谁占用">查看IPC资源被谁占用</h3>
<p>示例：有个IPCKEY(51036)，需要查询其是否被占用；</p>
<ol>
<li>
<p>首先通过计算器将其转为十六进制:</p>
<pre><code>51036 -&gt; c75c
</code></pre>
</li>
<li>
<p>如果知道是被共享内存占用:</p>
<pre><code>$ipcs -m | grep c75c
0x0000c75c 40403197   tdea3    666        536870912  2
</code></pre>
</li>
<li>
<p>如果不确定，则直接查找:</p>
<pre><code>$ipcs | grep c75c
0x0000c75c 40403197   tdea3    666        536870912  2
0x0000c75c 5079070    tdea3    666        4
</code></pre>
</li>
</ol>
<h2 id="72-系统ipc参数查询">7.2. 系统IPC参数查询</h2>
<pre><code>ipcs -l

------ Shared Memory Limits --------
max number of segments = 4096
max seg size (kbytes) = 4194303
max total shared memory (kbytes) = 1073741824
min seg size (bytes) = 1

------ Semaphore Limits --------
max number of arrays = 128
max semaphores per array = 250
max semaphores system wide = 32000
max ops per semop call = 32
semaphore max value = 32767

------ Messages: Limits --------
max queues system wide = 2048
max size of message (bytes) = 524288
default max size of queue (bytes) = 5242880
</code></pre>
<p>以上输出显示，目前这个系统的允许的最大内存为1073741824kb；最大可使用128个信号量，每个消息的最大长度为524288bytes；</p>
<h2 id="73-修改ipc系统参数">7.3. 修改IPC系统参数</h2>
<p>以linux系统为例，在root用户下修改/etc/sysctl.conf 文件，保存后使用sysctl -p生效:</p>
<pre><code>$cat /etc/sysctl.conf
# 一个消息的最大长度
kernel.msgmax = 524288

# 一个消息队列上的最大字节数
# 524288*10
kernel.msgmnb = 5242880

#最大消息队列的个数
kernel.msgmni=2048

#一个共享内存区的最大字节数
kernel.shmmax = 17179869184

#系统范围内最大共享内存标识数
kernel.shmmni=4096

#每个信号灯集的最大信号灯数 系统范围内最大信号灯数 每个信号灯支持的最大操作数 系统范围内最大信号灯集数
#此参数为系统默认，可以不用修改
#kernel.sem = &lt;semmsl&gt; &lt;semmni&gt;*&lt;semmsl&gt; &lt;semopm&gt; &lt;semmni&gt;
kernel.sem = 250 32000 32 128
</code></pre>
<p>显示输入不带标志的 ipcs：的输出:</p>
<pre><code>$ipcs
IPC status from /dev/mem as of Mon Aug 14 15:03:46 1989
T    ID         KEY        MODE       OWNER     GROUP
Message Queues:
q       0    0x00010381 -Rrw-rw-rw-   root      system
q   65537    0x00010307 -Rrw-rw-rw-   root      system
q   65538    0x00010311 -Rrw-rw-rw-   root      system
q   65539    0x0001032f -Rrw-rw-rw-   root      system
q   65540    0x0001031b -Rrw-rw-rw-   root      system
q   65541    0x00010339--rw-rw-rw-    root      system
q       6    0x0002fe03 -Rrw-rw-rw-   root      system
Shared Memory:
m   65537    0x00000000 DCrw-------   root      system
m  720898    0x00010300 -Crw-rw-rw-   root      system
m   65539    0x00000000 DCrw-------   root      system
Semaphores:
s  131072    0x4d02086a --ra-ra----   root      system
s   65537    0x00000000 --ra-------   root      system
s 1310722    0x000133d0 --ra-------   7003      30720
</code></pre>
<h2 id="74-清除ipc资源">7.4. 清除IPC资源</h2>
<p>使用ipcrm 命令来清除IPC资源：这个命令同时会将与ipc对象相关联的数据也一起移除。当然，只有root用户，或者ipc对象的创建者才有这项权利；</p>
<p>ipcrm用法:</p>
<pre><code>ipcrm -M shmkey  移除用shmkey创建的共享内存段
ipcrm -m shmid    移除用shmid标识的共享内存段
ipcrm -Q msgkey  移除用msqkey创建的消息队列
ipcrm -q msqid  移除用msqid标识的消息队列
ipcrm -S semkey  移除用semkey创建的信号
ipcrm -s semid  移除用semid标识的信号
</code></pre>
<p>清除当前用户创建的所有的IPC资源:</p>
<pre><code>ipcs -q | awk '{ print &quot;ipcrm -q &quot;$2}' | sh &gt; /dev/null 2&gt;&amp;1;
ipcs -m | awk '{ print &quot;ipcrm -m &quot;$2}' | sh &gt; /dev/null 2&gt;&amp;1;
ipcs -s | awk '{ print &quot;ipcrm -s &quot;$2}' | sh &gt; /dev/null 2&gt;&amp;1;
</code></pre>
<h2 id="75-综合应用">7.5. 综合应用</h2>
<h3 id="查询user1用户环境上是否存在积queue现象">查询user1用户环境上是否存在积Queue现象</h3>
<ol>
<li>
<p>查询队列Queue:</p>
<pre><code>$ipcs -q

------ Message Queues --------
key        msqid      owner      perms      used-bytes   messages
0x49060005 58261504   user1    660        0            0
0x4f060005 58294273   user1    660        0            0
...
</code></pre>
</li>
<li>
<p>找出第6列大于0的服务:</p>
<pre><code>$ ipcs -q |grep user1 |awk '{if($5&gt;0) print $0}'
0x00000000 1071579324 user1       644        1954530      4826
0x00000000 1071644862 user1       644        1961820      4844
0x00000000 1071677631 user1       644        1944810      4802
0x00000000 1071710400 user1       644        1961820      4844
</code></pre>
</li>
</ol>
<h1 id="8-top-linux下的任务管理器">8. top linux下的任务管理器</h1>
<p>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。</p>
<pre><code>$top
    top - 09:14:56 up 264 days, 20:56,  1 user,  load average: 0.02, 0.04, 0.00
    Tasks:  87 total,   1 running,  86 sleeping,   0 stopped,   0 zombie
    Cpu(s):  0.0%us,  0.2%sy,  0.0%ni, 99.7%id,  0.0%wa,  0.0%hi,  0.0%si,  0.2%st
    Mem:    377672k total,   322332k used,    55340k free,    32592k buffers
    Swap:   397308k total,    67192k used,   330116k free,    71900k cached
    PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
    1 root      20   0  2856  656  388 S  0.0  0.2   0:49.40 init
    2 root      20   0     0    0    0 S  0.0  0.0   0:00.00 kthreadd
    3 root      20   0     0    0    0 S  0.0  0.0   7:15.20 ksoftirqd/0
    4 root      RT   0     0    0    0 S  0.0  0.0   0:00.00 migration/0
</code></pre>
<ul>
<li>
<ul>
<li>
<p>第一行</p>
<p>09:14:56 ： 系统当前时间264 days, 20:56 ： 系统开机到现在经过了多少时间1 users ： 当前2用户在线load average: 0.02, 0.04, 0.00： 系统1分钟、5分钟、15分钟的CPU负载信息</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第二行</p>
<p>Tasks：任务;87 total：很好理解，就是当前有87个任务，也就是87个进程。1 running：1个进程正在运行86 sleeping：86个进程睡眠0 stopped：停止的进程数0 zombie：僵死的进程数</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第三行</p>
<p>Cpu(s)：表示这一行显示CPU总体信息0.0%us：用户态进程占用CPU时间百分比，不包含renice值为负的任务占用的CPU的时间。0.7%sy：内核占用CPU时间百分比0.0%ni：改变过优先级的进程占用CPU的百分比99.3%id：空闲CPU时间百分比0.0%wa：等待I/O的CPU时间百分比0.0%hi：CPU硬中断时间百分比0.0%si：CPU软中断时间百分比注：这里显示数据是所有cpu的平均值，如果想看每一个cpu的处理情况，按1即可；折叠，再次按1；</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第四行</p>
<p>Men：内存的意思8175320kk total：物理内存总量8058868k used：使用的物理内存量116452k free：空闲的物理内存量283084k buffers：用作内核缓存的物理内存量</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>第五行</p>
<p>Swap：交换空间6881272k total：交换区总量4010444k used：使用的交换区量2870828k free：空闲的交换区量4336992k cached：缓冲交换区总量</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>进程信息</p>
<p>再下面就是进程信息：PID：进程的IDUSER：进程所有者PR：进程的优先级别，越小越优先被执行NInice：值VIRT：进程占用的虚拟内存RES：进程占用的物理内存SHR：进程使用的共享内存S：进程的状态。S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值为负数%CPU：进程占用CPU的使用率%MEM：进程使用的物理内存和总内存的百分比TIME+：该进程启动后占用的总的CPU时间，即占用CPU使用时间的累加值。COMMAND：进程启动命令名称</p>
</li>
</ul>
</li>
</ul>
<h2 id="81-top命令交互操作指令">8.1. top命令交互操作指令</h2>
<p>下面列出一些常用的 top命令操作指令</p>
<blockquote>
<ul>
<li>q：退出top命令</li>
<li><Space>：立即刷新</li>
<li>s：设置刷新时间间隔</li>
<li>c：显示命令完全模式</li>
<li>t:：显示或隐藏进程和CPU状态信息</li>
<li>m：显示或隐藏内存状态信息</li>
<li>l：显示或隐藏uptime信息</li>
<li>f：增加或减少进程显示标志</li>
<li>S：累计模式，会把已完成或退出的子进程占用的CPU时间累计到父进程的MITE+</li>
<li>P：按%CPU使用率排行</li>
<li>T：按MITE+排行</li>
<li>M：按%MEM排行</li>
<li>u：指定显示用户进程</li>
<li>r：修改进程renice值</li>
<li>kkill：进程</li>
<li>i：只显示正在运行的进程</li>
<li>W：保存对top的设置到文件^/.toprc，下次启动将自动调用toprc文件的设置。</li>
<li>h：帮助命令。</li>
<li>q：退出</li>
</ul>
</blockquote>
<p>注：强调一下，使用频率最高的是P、T、M，因为通常使用top，我们就想看看是哪些进程最耗cpu资源、占用的内存最多； 注：通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列 如果只需要查看内存：可用free命令。只查看uptime信息（第一行），可用uptime命令；</p>
<h2 id="82-实例">8.2. 实例</h2>
<h3 id="实例1多核cpu监控">实例1：多核CPU监控</h3>
<p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况；</p>
<pre><code>[rdtfr@bl685cb4-t ^]$ top
top - 09:10:44 up 20 days, 16:51,  4 users,  load average: 3.82, 4.40, 4.40
Tasks: 1201 total,  10 running, 1189 sleeping,   0 stopped,   2 zombie
Cpu0  :  1.3%us,  2.3%sy,  0.0%ni, 96.4%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu1  :  1.3%us,  2.6%sy,  0.0%ni, 96.1%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu2  :  1.0%us,  2.0%sy,  0.0%ni, 92.5%id,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st
Cpu3  :  3.9%us,  7.8%sy,  0.0%ni, 83.2%id,  0.0%wa,  0.0%hi,  5.2%si,  0.0%st
Cpu4  :  4.2%us, 10.4%sy,  0.0%ni, 63.8%id,  0.0%wa,  0.0%hi, 21.5%si,  0.0%st
Cpu5  :  6.8%us, 12.7%sy,  0.0%ni, 80.5%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Cpu6  :  2.9%us,  7.2%sy,  0.0%ni, 85.3%id,  0.0%wa,  0.0%hi,  4.6%si,  0.0%st
Cpu7  :  6.2%us, 13.0%sy,  0.0%ni, 75.3%id,  0.0%wa,  0.0%hi,  5.5%si,  0.0%st
Mem:  32943888k total, 32834216k used,   109672k free,   642704k buffers
Swap: 35651576k total,  5761928k used, 29889648k free, 16611500k cached
</code></pre>
<h3 id="实例2高亮显示当前运行进程">实例2：高亮显示当前运行进程</h3>
<pre><code>在top基本视图中,按键盘“b”（打开/关闭加亮效果）；
</code></pre>
<h3 id="实例3显示完整的程序命令">实例3：显示完整的程序命令</h3>
<p>命令：top -c</p>
<pre><code>[rdtfr@bl685cb4-t ^]$ top -c
top - 09:14:35 up 20 days, 16:55,  4 users,  load average: 5.77, 5.01, 4.64
Tasks: 1200 total,   5 running, 1192 sleeping,   0 stopped,   3 zombie
Cpu(s):  4.4%us,  6.0%sy,  0.0%ni, 83.8%id,  0.2%wa,  0.0%hi,  5.5%si,  0.0%st
Mem:  32943888k total, 32842896k used,   100992k free,   591484k buffers
Swap: 35651576k total,  5761808k used, 29889768k free, 16918824k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
2013 apache    18   0  403m  88m 5304 S 25.0  0.3   6:37.44 /usr/sbin/httpd
18335 pubtest   22   0 65576  996  728 R  7.8  0.0   0:00.24 netstat -naltp
16499 rdtfare   15   0 13672 2080  824 R  2.6  0.0   0:00.38 top -c
29684 rdtfare   15   0 1164m 837m  14m S  2.3  2.6 148:47.54 ./autodata data1.txt
12976 pubtest   18   0  238m 9000 1932 S  1.6  0.0 439:28.44 tscagent -s TOEV_P
</code></pre>
<h3 id="实例4显示指定的进程信息">实例4：显示指定的进程信息</h3>
<p>命令：top -p pidid</p>
<pre><code>/opt/app/tdv1/config#top -p 17265
top - 09:17:34 up 455 days, 17:55,  2 users,  load average: 3.76, 4.56, 4.46
Tasks:   1 total,   0 running,   1 sleeping,   0 stopped,   0 zombie
Cpu(s):  7.8%us,  1.9%sy,  0.0%ni, 89.2%id,  0.0%wa,  0.1%hi,  1.0%si,  0.0%st
Mem:   8175452k total,  8103988k used,    71464k free,   268716k buffers
Swap:  6881272k total,  4275424k used,  2605848k free,  6338184k cached
PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND
17265 tdv1      15   0 56504  828  632 S  0.0  0.0 195:53.25 redis-server
</code></pre>
<p>指定进程信息有多个时，需要结合其它工具将回车替换为,（-p 支持pid,pid,pid语法）</p>
<p>命令：top -p pgrep MULTI_PROCESS | tr “\n” ”,” | sed ‘s/,$//’</p>
<pre><code>/opt/app/tdv1$top -p `pgrep java | tr &quot;\\n&quot; &quot;,&quot; | sed 's/,$//'`
top - 14:05:31 up 53 days,  2:43,  9 users,  load average: 0.29, 0.34, 0.22
Tasks:   3 total,   0 running,   3 sleeping,   0 stopped,   0 zombie
Cpu(s):  5.9%us,  8.2%sy,  0.0%ni, 86.0%id,  0.0%wa,  0.0%hi,  0.0%si,  0.0%st
Mem:  66082088k total, 29512860k used, 36569228k free,   756352k buffers
Swap: 32767992k total,  1019900k used, 31748092k free, 15710284k cached

  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                          27855 rdtfare   20   0 4454m 1.3g 5300 S  0.7  2.0 338:31.37 java
 2034 jenkins   20   0 18.3g 5.2g 5284 S  0.3  8.2  56:02.38 java                                             12156 rdtfare   20   0 4196m 1.2g  12m S  0.3  2.0  86:34.62 java
</code></pre>
<h2 id="83-更强大的工具">8.3. 更强大的工具</h2>
<h3 id="htop">htop</h3>
<p>htop 是一个 Linux 下的交互式的进程浏览器，可以用来替换Linux下的top命令。</p>
<p>与Linux传统的top相比，htop更加人性化。它可让用户交互式操作，支持颜色主题，可横向或纵向滚动浏览进程列表，并支持鼠标操作。</p>
<p>与top相比，htop有以下优点：</p>
<ul>
<li>可以横向或纵向滚动浏览进程列表，以便看到所有的进程和完整的命令行。</li>
<li>在启动上，比top 更快。</li>
<li>杀进程时不需要输入进程号。</li>
<li>htop 支持鼠标操作。</li>
</ul>
<h1 id="9-free-查询可用内存">9. free 查询可用内存</h1>
<p>free工具用来查看系统可用内存:</p>
<pre><code>/opt/app/tdev1$free
             total       used       free     shared    buffers     cached
Mem:       8175320    6159248    2016072          0     310208    5243680
-/+ buffers/cache:     605360    7569960
Swap:      6881272      16196    6865076
</code></pre>
<p>解释一下Linux上free命令的输出。</p>
<p>下面是free的运行结果，一共有4行。为了方便说明，我加上了列号。这样可以把free的输出看成一个二维数组FO(Free Output)。例如:</p>
<pre><code>FO[2][1] = 24677460
FO[3][2] = 10321516

                   1          2          3          4          5          6
1              total       used       free     shared    buffers     cached
2 Mem:      24677460   23276064    1401396          0     870540   12084008
3 -/+ buffers/cache:   10321516   14355944
4 Swap:     25151484     224188   24927296
</code></pre>
<p>free的输出一共有四行，第四行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。</p>
<p>free输出地第二行和第三行是比较让人迷惑的。这两行都是说明内存使用情况的。第一列是总量（total），第二列是使用量（used），第三列是可用量（free）。</p>
<p>第一行的输出时从操作系统（OS）来看的。也就是说，从OS的角度来看，计算机上一共有:</p>
<p>24677460KB（缺省时free的单位为KB）物理内存，即FO[2][1]； 在这些物理内存中有23276064KB（即FO[2][2]）被使用了； 还用1401396KB（即FO[2][3]）是可用的；</p>
<p>这里得到第一个等式：</p>
<p>FO[2][1] = FO[2][2] + FO[2][3]</p>
<p>FO[2][4]表示被几个进程共享的内存的，现在已经deprecated，其值总是0（当然在一些系统上也可能不是0，主要取决于free命令是怎么实现的）。</p>
<p>FO[2][5]表示被OS buffer住的内存。FO[2][6]表示被OS cache的内存。在有些时候buffer和cache这两个词经常混用。不过在一些比较低层的软件里是要区分这两个词的，看老外的洋文:</p>
<pre><code>A buffer is something that has yet to be &quot;written&quot; to disk.
A cache is something that has been &quot;read&quot; from the disk and stored for later use.
</code></pre>
<p>也就是说buffer是用于存放要输出到disk（块设备）的数据的，而cache是存放从disk上读出的数据。这二者是为了提高IO性能的，并由OS管理。</p>
<p>Linux和其他成熟的操作系统（例如windows），为了提高IO read的性能，总是要多cache一些数据，这也就是为什么FO[2][6]（cached memory）比较大，而FO[2][3]比较小的原因。我们可以做一个简单的测试:</p>
<p>释放掉被系统cache占用的数据:</p>
<pre><code>echo 3&gt;/proc/sys/vm/drop_caches
</code></pre>
<ol>
<li>读一个大文件，并记录时间；</li>
<li>关闭该文件；</li>
<li>重读这个大文件，并记录时间；</li>
</ol>
<p>第二次读应该比第一次快很多。原来我做过一个BerkeleyDB的读操作，大概要读5G的文件，几千万条记录。在我的环境上，第二次读比第一次大概可以快9倍左右。</p>
<p>free输出的第二行是从一个应用程序的角度看系统内存的使用情况。</p>
<ul>
<li>对于FO[3][2]，即-buffers/cache，表示一个应用程序认为系统被用掉多少内存；</li>
<li>对于FO[3][3]，即+buffers/cache，表示一个应用程序认为系统还有多少内存；</li>
</ul>
<p>因为被系统cache和buffer占用的内存可以被快速回收，所以通常FO[3][3]比FO[2][3]会大很多。</p>
<p>这里还用两个等式:</p>
<pre><code>FO[3][2] = FO[2][2] - FO[2][5] - FO[2][6]
FO[3][3] = FO[2][3] + FO[2][5] + FO[2][6]
</code></pre>
<p>这二者都不难理解。</p>
<p>free命令由procps.*.rpm提供（在Redhat系列的OS上）。free命令的所有输出值都是从/proc/meminfo中读出的。</p>
<p>在系统上可能有meminfo(2)这个函数，它就是为了解析/proc/meminfo的。procps这个包自己实现了meminfo()这个函数。可以下载一个procps的tar包看看具体实现，现在最新版式3.2.8。</p>
<h1 id="10-vmstat-监视内存使用情况">10. vmstat 监视内存使用情况</h1>
<p>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可实时动态监视操作系统的虚拟内存、进程、CPU活动。</p>
<h2 id="101-vmstat的语法">10.1. vmstat的语法</h2>
<p>vmstat [-V] [-n] [delay [count]]</p>
<blockquote>
<ul>
<li>-V表示打印出版本信息；</li>
<li>-n表示在周期性循环输出时，输出的头部信息仅显示一次；</li>
<li>delay是两次输出之间的延迟时间；</li>
<li>count是指按照这个时间间隔统计的次数。</li>
</ul>
</blockquote>
<pre><code>/root$vmstat 5 5
procs -----------memory---------- ---swap-- -----io---- --system-- -----cpu-----
r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
6  0      0 27900472 204216 28188356    0    0     0     9    1    2 11 14 75  0  0
9  0      0 27900380 204228 28188360    0    0     0    13 33312 126221 22 20 58  0  0
2  0      0 27900340 204240 28188364    0    0     0    10 32755 125566 22 20 58  0  0
</code></pre>
<h2 id="102-字段说明">10.2. 字段说明</h2>
<ul>
<li>
<p>Procs（进程）:</p>
<p>r: 运行队列中进程数量b: 等待IO的进程数量</p>
</li>
<li>
<p>Memory（内存）:</p>
<p>swpd: 使用虚拟内存大小free: 可用内存大小buff: 用作缓冲的内存大小cache: 用作缓存的内存大小</p>
</li>
<li>
<p>Swap:</p>
<p>si: 每秒从交换区写到内存的大小so: 每秒写入交换区的内存大小</p>
</li>
<li>
<p>IO：（现在的Linux版本块的大小为1024bytes）</p>
<p>bi: 每秒读取的块数bo: 每秒写入的块数</p>
</li>
<li>
<p>system：</p>
<p>in: 每秒中断数，包括时钟中断cs: 每秒上下文切换数</p>
</li>
<li>
<p>CPU（以百分比表示）</p>
<p>us: 用户进程执行时间(user time)sy: 系统进程执行时间(system time)id: 空闲时间(包括IO等待时间)wa: 等待IO时间</p>
</li>
</ul>
<h1 id="11-iostat-监视io子系统">11. iostat 监视I/O子系统</h1>
<p>iostat是I/O statistics（输入/输出统计）的缩写，用来动态监视系统的磁盘操作活动。</p>
<h2 id="111-命令格式">11.1. 命令格式</h2>
<p>iostat[参数][时间][次数]</p>
<h2 id="112-命令功能">11.2. 命令功能</h2>
<p>通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。</p>
<h2 id="113-命令参数">11.3. 命令参数</h2>
<ul>
<li>-C 显示CPU使用情况</li>
<li>-d 显示磁盘使用情况</li>
<li>-k 以 KB 为单位显示</li>
<li>-m 以 M 为单位显示</li>
<li>-N 显示磁盘阵列(LVM) 信息</li>
<li>-n 显示NFS 使用情况</li>
<li>-p[磁盘] 显示磁盘和分区的情况</li>
<li>-t 显示终端和CPU的信息</li>
<li>-x 显示详细信息</li>
<li>-V 显示版本信息</li>
</ul>
<h2 id="114-工具实例">11.4. 工具实例</h2>
<h3 id="实例1显示所有设备负载情况">实例1：显示所有设备负载情况</h3>
<pre><code>/root$iostat
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
10.81    0.00   14.11    0.18    0.00   74.90

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               1.95         1.48        70.88    9145160  437100644
dm-0              3.08         0.55        24.34    3392770  150087080
dm-1              5.83         0.93        46.49    5714522  286724168
dm-2              0.01         0.00         0.05      23930     289288
</code></pre>
<ul>
<li>
<p>cpu属性值说明：</p>
<p>%user：CPU处在用户模式下的时间百分比。%nice：CPU处在带NICE值的用户模式下的时间百分比。%system：CPU处在系统模式下的时间百分比。%iowait：CPU等待输入输出完成时间的百分比。%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。%idle：CPU空闲时间百分比。</p>
</li>
</ul>
<p>注：如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p>
<ul>
<li>
<p>disk属性值说明：</p>
<p>rrqm/s: 每秒进行 merge 的读操作数目。即 rmerge/swrqm/s: 每秒进行 merge 的写操作数目。即 wmerge/sr/s: 每秒完成的读 I/O 设备次数。即 rio/sw/s: 每秒完成的写 I/O 设备次数。即 wio/srsec/s: 每秒读扇区数。即 rsect/swsec/s: 每秒写扇区数。即 wsect/srkB/s: 每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。wkB/s: 每秒写K字节数。是 wsect/s 的一半。avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)。avgqu-sz: 平均I/O队列长度。await: 平均每次设备I/O操作的等待时间 (毫秒)。svctm: 平均每次设备I/O操作的服务时间 (毫秒)。%util: 一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</p>
</li>
</ul>
<p>备注：如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有当量io在等待。</p>
<h3 id="实例2定时显示所有信息">实例2：定时显示所有信息</h3>
<pre><code>/root$iostat 2 3
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
10.81    0.00   14.11    0.18    0.00   74.90

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               1.95         1.48        70.88    9145160  437106156
dm-0              3.08         0.55        24.34    3392770  150088376
dm-1              5.83         0.93        46.49    5714522  286728384
dm-2              0.01         0.00         0.05      23930     289288

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
22.62    0.00   19.67    0.26    0.00   57.46

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               2.50         0.00        28.00          0         56
dm-0              0.00         0.00         0.00          0          0
dm-1              3.50         0.00        28.00          0         56
dm-2              0.00         0.00         0.00          0          0

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
22.69    0.00   19.62    0.00    0.00   57.69

Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn
sda               0.00         0.00         0.00          0          0
dm-0              0.00         0.00         0.00          0          0
dm-1              0.00         0.00         0.00          0          0
dm-2              0.00         0.00         0.00          0          0
</code></pre>
<p>说明：每隔 2秒刷新显示，且显示3次</p>
<h3 id="实例3查看tps和吞吐量">实例3：查看TPS和吞吐量</h3>
<pre><code>/root$iostat -d -k 1 1
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
sda               1.95         0.74        35.44    4572712  218559410
dm-0              3.08         0.28        12.17    1696513   75045968
dm-1              5.83         0.46        23.25    2857265  143368744
dm-2              0.01         0.00         0.02      11965     144644
</code></pre>
<ul>
<li>tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。</li>
<li>kB_read/s：每秒从设备（drive expressed）读取的数据量；</li>
<li>kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</li>
<li>kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；</li>
</ul>
<p>这些单位都为Kilobytes。</p>
<p>上面的例子中，我们可以看到磁盘sda以及它的各个分区的统计数据，当时统计的磁盘总TPS是1.95，下面是各个分区的TPS。（因为是瞬间值，所以总TPS并不严格等于各个分区TPS的总和）</p>
<h3 id="实例4查看设备使用率util和响应时间await">实例4：查看设备使用率（%util）和响应时间（await）</h3>
<pre><code>/root$iostat -d -x -k 1 1
Linux 2.6.32-279.el6.x86_64 (colin)   07/16/2014      _x86_64_        (4 CPU)

Device:         rrqm/s   wrqm/s     r/s     w/s    rkB/s    wkB/s avgrq-sz avgqu-sz   await  svctm  %util
sda               0.02     7.25    0.04    1.90     0.74    35.47    37.15     0.04   19.13   5.58   1.09
dm-0              0.00     0.00    0.04    3.05     0.28    12.18     8.07     0.65  209.01   1.11   0.34
dm-1              0.00     0.00    0.02    5.82     0.46    23.26     8.13     0.43   74.33   1.30   0.76
dm-2              0.00     0.00    0.00    0.01     0.00     0.02     8.00     0.00    5.41   3.28   0.00
</code></pre>
<ul>
<li>rrqm/s： 每秒进行 merge 的读操作数目.即 delta(rmerge)/s</li>
<li>wrqm/s： 每秒进行 merge 的写操作数目.即 delta(wmerge)/s</li>
<li>r/s： 每秒完成的读 I/O 设备次数.即 delta(rio)/s</li>
<li>w/s： 每秒完成的写 I/O 设备次数.即 delta(wio)/s</li>
<li>rsec/s： 每秒读扇区数.即 delta(rsect)/s</li>
<li>wsec/s： 每秒写扇区数.即 delta(wsect)/s</li>
<li>rkB/s： 每秒读K字节数.是 rsect/s 的一半,因为每扇区大小为512字节.(需要计算)</li>
<li>wkB/s： 每秒写K字节数.是 wsect/s 的一半.(需要计算)</li>
<li>avgrq-sz：平均每次设备I/O操作的数据大小 (扇区).delta(rsect+wsect)/delta(rio+wio)</li>
<li>avgqu-sz：平均I/O队列长度.即 delta(aveq)/s/1000 (因为aveq的单位为毫秒).</li>
<li>await： 平均每次设备I/O操作的等待时间 (毫秒).即 delta(ruse+wuse)/delta(rio+wio)</li>
<li>svctm： 平均每次设备I/O操作的服务时间 (毫秒).即 delta(use)/delta(rio+wio)</li>
<li>%util： 一秒中有百分之多少的时间用于 I/O 操作,或者说一秒中有多少时间 I/O 队列是非空的，即 delta(use)/s/1000 (因为use的单位为毫秒)</li>
</ul>
<p>如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。 idle小于70% IO压力就较大了，一般读取速度有较多的wait。 同时可以结合vmstat 查看查看b参数(等待资源的进程数)和wa参数(IO等待所占用的CPU时间的百分比，高过30%时IO压力高)。</p>
<p>另外 await 的参数也要多和 svctm 来参考。差的过高就一定有 IO 的问题。</p>
<p>avgqu-sz 也是个做 IO 调优时需要注意的地方，这个就是直接每次操作的数据的大小，如果次数多，但数据拿的小的话，其实 IO 也会很小。如果数据拿的大，才IO 的数据会高。也可以通过 avgqu-sz × ( r/s or w/s ) = rsec/s or wsec/s。也就是讲，读定速度是这个来决定的。</p>
<p>svctm 一般要小于 await (因为同时等待的请求的等待时间被重复计算了)，svctm 的大小一般和磁盘性能有关，CPU/内存的负荷也会对其有影响，请求过多也会间接导致 svctm 的增加。await 的大小一般取决于服务时间(svctm) 以及 I/O 队列的长度和 I/O 请求的发出模式。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明 I/O 队列太长，应用得到的响应时间变慢，如果响应时间超过了用户可以容许的范围，这时可以考虑更换更快的磁盘，调整内核 elevator 算法，优化应用，或者升级 CPU。</p>
<p>队列长度(avgqu-sz)也可作为衡量系统 I/O 负荷的指标，但由于 avgqu-sz 是按照单位时间的平均值，所以不能反映瞬间的 I/O 洪水。</p>
<ul>
<li>
<p>形象的比喻：</p>
<p>r/s+w/s 类似于交款人的总数平均队列长度(avgqu-sz)类似于单位时间里平均排队人的个数平均服务时间(svctm)类似于收银员的收款速度平均等待时间(await)类似于平均每人的等待时间平均I/O数据(avgrq-sz)类似于平均每人所买的东西多少I/O 操作率 (%util)类似于收款台前有人排队的时间比例</p>
</li>
</ul>
<p>设备IO操作:总IO(io)/s = r/s(读) +w/s(写)</p>
<p>平均等待时间=单个I/O服务器时间*(1+2+...+请求总数-1)/请求总数</p>
<p>每秒发出的I/0请求很多,但是平均队列就4,表示这些请求比较均匀,大部分处理还是比较及时。</p>
<h1 id="12-sar-找出系统瓶颈的利器">12. sar 找出系统瓶颈的利器</h1>
<p>sar是System Activity Reporter（系统活动情况报告）的缩写。sar工具将对系统当前的状态进行取样，然后通过计算数据和比例来表达系统的当前运行状态。它的特点是可以连续对系统取样，获得大量的取样数据；取样数据和分析的结果都可以存入文件，所需的负载很小。sar是目前Linux上最为全面的系统性能分析工具之一，可以从14个大方面对系统的活动进行报告，包括文件的读写情况、系统调用的使用情况、串口、CPU效率、内存使用状况、进程活动及IPC有关的活动等，使用也是较为复杂。</p>
<p>sar是查看操作系统报告指标的各种工具中，最为普遍和方便的；它有两种用法；</p>
<ol>
<li>追溯过去的统计数据（默认）</li>
<li>周期性的查看当前数据</li>
</ol>
<h2 id="121-追溯过去的统计数据">12.1. 追溯过去的统计数据</h2>
<p>默认情况下，sar从最近的0点0分开始显示数据；如果想继续查看一天前的报告；可以查看保存在/var/log/sysstat/下的sa日志； 使用sar工具查看:</p>
<pre><code>$sar -f /var/log/sysstat/sa28 \| head sar -r -f
/var/log/sysstat/sa28
</code></pre>
<figure data-type="image" tabindex="1"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar1.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar1.png" alt="../_images/sar1.png" loading="lazy"></a></figure>
<h2 id="122-查看cpu使用率">12.2. 查看CPU使用率</h2>
<p>sar -u : 默认情况下显示的cpu使用率等信息就是sar -u；</p>
<figure data-type="image" tabindex="2"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar2.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar2.png" alt="../_images/sar2.png" loading="lazy"></a></figure>
<p>可以看到这台机器使用了虚拟化技术，有相应的时间消耗； 各列的指标分别是:</p>
<ul>
<li>%user 用户模式下消耗的CPU时间的比例；</li>
<li>%nice 通过nice改变了进程调度优先级的进程，在用户模式下消耗的CPU时间的比例</li>
<li>%system 系统模式下消耗的CPU时间的比例；</li>
<li>%iowait CPU等待磁盘I/O导致空闲状态消耗的时间比例；</li>
<li>%steal 利用Xen等操作系统虚拟化技术，等待其它虚拟CPU计算占用的时间比例；</li>
<li>%idle CPU空闲时间比例；</li>
</ul>
<h2 id="123-查看平均负载">12.3. 查看平均负载</h2>
<p>sar -q: 查看平均负载</p>
<p>指定-q后，就能查看运行队列中的进程数、系统上的进程大小、平均负载等；与其它命令相比，它能查看各项指标随时间变化的情况；</p>
<ul>
<li>runq-sz：运行队列的长度（等待运行的进程数）</li>
<li>plist-sz：进程列表中进程（processes）和线程（threads）的数量</li>
<li>ldavg-1：最后1分钟的系统平均负载 ldavg-5：过去5分钟的系统平均负载</li>
<li>ldavg-15：过去15分钟的系统平均负载</li>
</ul>
<figure data-type="image" tabindex="3"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar3.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar3.png" alt="../_images/sar3.png" loading="lazy"></a></figure>
<h2 id="124-查看内存使用状况">12.4. 查看内存使用状况</h2>
<p>sar -r： 指定-r之后，可查看物理内存使用状况；</p>
<figure data-type="image" tabindex="4"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar4.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar4.png" alt="../_images/sar4.png" loading="lazy"></a></figure>
<ul>
<li>kbmemfree：这个值和free命令中的free值基本一致,所以它不包括buffer和cache的空间.</li>
<li>kbmemused：这个值和free命令中的used值基本一致,所以它包括buffer和cache的空间.</li>
<li>%memused：物理内存使用率，这个值是kbmemused和内存总量(不包括swap)的一个百分比.</li>
<li>kbbuffers和kbcached：这两个值就是free命令中的buffer和cache.</li>
<li>kbcommit：保证当前系统所需要的内存,即为了确保不溢出而需要的内存(RAM+swap).</li>
<li>%commit：这个值是kbcommit与内存总量(包括swap)的一个百分比.</li>
</ul>
<h2 id="125-查看页面交换发生状况">12.5. 查看页面交换发生状况</h2>
<p>sar -W：查看页面交换发生状况</p>
<p>页面发生交换时，服务器的吞吐量会大幅下降；服务器状况不良时，如果怀疑因为内存不足而导致了页面交换的发生，可以使用这个命令来确认是否发生了大量的交换；</p>
<figure data-type="image" tabindex="5"><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar5.png"><img src="https://linuxtools-rst.readthedocs.io/zh_CN/latest/_images/sar5.png" alt="../_images/sar5.png" loading="lazy"></a></figure>
<ul>
<li>pswpin/s：每秒系统换入的交换页面（swap page）数量</li>
<li>pswpout/s：每秒系统换出的交换页面（swap page）数量</li>
</ul>
<p>要判断系统瓶颈问题，有时需几个 sar 命令选项结合起来；</p>
<ul>
<li>怀疑CPU存在瓶颈，可用 sar -u 和 sar -q 等来查看</li>
<li>怀疑内存存在瓶颈，可用sar -B、sar -r 和 sar -W 等来查看</li>
<li>怀疑I/O存在瓶颈，可用 sar -b、sar -u 和 sar -d 等来查看</li>
</ul>
<h2 id="126-安装">12.6. 安装</h2>
<ol>
<li>有的linux系统下，默认可能没有安装这个包，使用apt-get install sysstat 来安装；</li>
<li>安装完毕，将性能收集工具的开关打开： vi /etc/default/sysstat</li>
</ol>
<blockquote>
<p>设置 ENABLED=”true”</p>
</blockquote>
<ol>
<li>启动这个工具来收集系统性能数据： /etc/init.d/sysstat start</li>
</ol>
<h2 id="127-sar参数说明">12.7. sar参数说明</h2>
<ul>
<li>-A 汇总所有的报告</li>
<li>-a 报告文件读写使用情况</li>
<li>-B 报告附加的缓存的使用情况</li>
<li>-b 报告缓存的使用情况</li>
<li>-c 报告系统调用的使用情况</li>
<li>-d 报告磁盘的使用情况</li>
<li>-g 报告串口的使用情况</li>
<li>-h 报告关于buffer使用的统计数据</li>
<li>-m 报告IPC消息队列和信号量的使用情况</li>
<li>-n 报告命名cache的使用情况</li>
<li>-p 报告调页活动的使用情况</li>
<li>-q 报告运行队列和交换队列的平均长度</li>
<li>-R 报告进程的活动情况</li>
<li>-r 报告没有使用的内存页面和硬盘块</li>
<li>-u 报告CPU的利用率</li>
<li>-v 报告进程、i节点、文件和锁表状态</li>
<li>-w 报告系统交换活动状况</li>
<li>-y 报告TTY设备活动状况</li>
</ul>
<h1 id="13-readelf-elf文件格式分析">13. readelf elf文件格式分析</h1>
<p>这个工具和objdump命令提供的功能类似，但是它显示的信息更为具体，并且它不依赖BFD库(BFD库是一个GNU项目，它的目标就是希望通过一种统一的接口来处理不同的目标文件）；</p>
<ul>
<li>
<p><strong>ELF文件类型</strong></p>
<p>ELF(Executable and Linking Format)是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。它自最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。可以说，ELF是构成众多xNIX系统的基础之一。</p>
</li>
</ul>
<p>ELF文件有三种类型：</p>
<ol>
<li>
<ul>
<li>
<p>可重定位的对象文件(Relocatable file)</p>
<p>由汇编器汇编生成的 .o 文件</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>可执行的对象文件(Executable file)</p>
<p>可执行应用程序</p>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>可被共享的对象文件(Shared object file)</p>
<p>动态库文件，也即 .so 文件</p>
</li>
</ul>
</li>
</ol>
<ul>
<li>.text section 里装载了可执行代码；</li>
<li>.data section 里面装载了被初始化的数据；</li>
<li>.bss section 里面装载了未被初始化的数据；</li>
<li>以 .rec 打头的 sections 里面装载了重定位条目；</li>
<li>.symtab 或者 .dynsym section 里面装载了符号信息；</li>
<li>.strtab 或者 .dynstr section 里面装载了字符串信息；</li>
</ul>
<h2 id="131-参数说明">13.1. 参数说明</h2>
<ul>
<li>
<p>-a –all 全部 Equivalent to: -h -l -S -s -r -d -V -A -I</p>
</li>
<li>
<p>-h –file-header 文件头 Display the ELF file header</p>
</li>
<li>
<p>-l –program-headers 程序 Display the program headers</p>
</li>
<li>
<p>–segments An alias for –program-headers</p>
</li>
<li>
<p>-S –section-headers 段头 Display the sections’ header</p>
</li>
<li>
<table>
<thead>
<tr>
<th>--sections</th>
<th>An alias for –section-headers</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>-e –headers 全部头 Equivalent to: -h -l -S</p>
</li>
<li>
<p>-s –syms 符号表 Display the symbol table</p>
</li>
<li>
<table>
<thead>
<tr>
<th>--symbols</th>
<th>An alias for –syms</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>-n –notes 内核注释 Display the core notes (if present)</p>
</li>
<li>
<p>-r –relocs 重定位 Display the relocations (if present)</p>
</li>
<li>
<p>-u –unwind Display the unwind info (if present)</p>
</li>
<li>
<p>-d –dynamic 动态段 Display the dynamic segment (if present)</p>
</li>
<li>
<p>-V –version-info 版本 Display the version sections (if present)</p>
</li>
<li>
<p>-A –arch-specific CPU构架 Display architecture specific information (if any).</p>
</li>
<li>
<p>-D –use-dynamic 动态段 Use the dynamic section info when displaying symbols</p>
</li>
<li>
<p>-x –hex-dump=<number> 显示 段内内容Dump the contents of section <number></p>
</li>
<li>
<p>-w[liaprmfFso] or</p>
</li>
<li>
<p>-I –histogram Display histogram of bucket list lengths</p>
</li>
<li>
<p>-W –wide 宽行输出 Allow output width to exceed 80 characters</p>
</li>
<li>
<p>-H –help Display this information</p>
</li>
<li>
<p>-v –version Display the version number of readelf</p>
</li>
</ul>
<h2 id="132-示例">13.2. 示例</h2>
<p>想知道一个应用程序的可运行的架构平台:</p>
<pre><code>$readelf -h main| grep Machine
</code></pre>
<p>-h选项将显示文件头的概要信息，从里面可以看到，有很多有用的信息：</p>
<pre><code>$readelf -h main
ELF Header:
Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
Class:                             ELF64
Data:                              2 s complement, little endian
Version:                           1 (current)
OS/ABI:                            UNIX - System V
ABI Version:                       0
Type:                              EXEC (Executable file)
Machine:                           Advanced Micro Devices X86-64
Version:                           0x1
Entry point address:               0x400790
Start of program headers:          64 (bytes into file)
Start of section headers:          5224 (bytes into file)
Flags:                             0x0
Size of this header:               64 (bytes)
Size of program headers:           56 (bytes)
Number of program headers:         8
Size of section headers:           64 (bytes)
Number of section headers:         29
Section header string table index: 26
</code></pre>
<p>一个编译好的应用程序，想知道其编译时是否使用了-g选项（加入调试信息）:</p>
<pre><code>$readelf -S main| grep debug
</code></pre>
<p>用-S选项是显示所有段信息；如果编译时使用了-g选项，则会有debug段;</p>
<p>查看.o文件是否编入了调试信息（编译的时候是否加了-g):</p>
<pre><code>$readelf -S Shpos.o | grep debug
</code></pre>
<h2 id="133-完整输出">13.3. 完整输出</h2>
<p>readelf输出的完整内容:</p>
<pre><code>$readelf -all a.out
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048330
  Start of program headers:          52 (bytes into file)
  Start of section headers:          4412 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         9
  Size of section headers:           40 (bytes)
  Number of section headers:         30
  Section header string table index: 27

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .interp           PROGBITS        08048154 000154 000013 00   A  0   0  1
  [ 2] .note.ABI-tag     NOTE            08048168 000168 000020 00   A  0   0  4
  [ 3] .note.gnu.build-i NOTE            08048188 000188 000024 00   A  0   0  4
  [ 4] .gnu.hash         GNU_HASH        080481ac 0001ac 000020 04   A  5   0  4
  [ 5] .dynsym           DYNSYM          080481cc 0001cc 000050 10   A  6   1  4
  [ 6] .dynstr           STRTAB          0804821c 00021c 00004c 00   A  0   0  1
  [ 7] .gnu.version      VERSYM          08048268 000268 00000a 02   A  5   0  2
  [ 8] .gnu.version_r    VERNEED         08048274 000274 000020 00   A  6   1  4
  [ 9] .rel.dyn          REL             08048294 000294 000008 08   A  5   0  4
  [10] .rel.plt          REL             0804829c 00029c 000018 08   A  5  12  4
  [11] .init             PROGBITS        080482b4 0002b4 00002e 00  AX  0   0  4
  [12] .plt              PROGBITS        080482f0 0002f0 000040 04  AX  0   0 16
  [13] .text             PROGBITS        08048330 000330 00018c 00  AX  0   0 16
  [14] .fini             PROGBITS        080484bc 0004bc 00001a 00  AX  0   0  4
  [15] .rodata           PROGBITS        080484d8 0004d8 000011 00   A  0   0  4
  [16] .eh_frame_hdr     PROGBITS        080484ec 0004ec 000034 00   A  0   0  4
  [17] .eh_frame         PROGBITS        08048520 000520 0000c4 00   A  0   0  4
  [18] .ctors            PROGBITS        08049f14 000f14 000008 00  WA  0   0  4
  [19] .dtors            PROGBITS        08049f1c 000f1c 000008 00  WA  0   0  4
  [20] .jcr              PROGBITS        08049f24 000f24 000004 00  WA  0   0  4
  [21] .dynamic          DYNAMIC         08049f28 000f28 0000c8 08  WA  6   0  4
  [22] .got              PROGBITS        08049ff0 000ff0 000004 04  WA  0   0  4
  [23] .got.plt          PROGBITS        08049ff4 000ff4 000018 04  WA  0   0  4
  [24] .data             PROGBITS        0804a00c 00100c 000008 00  WA  0   0  4
  [25] .bss              NOBITS          0804a014 001014 000008 00  WA  0   0  4
  [26] .comment          PROGBITS        00000000 001014 00002a 01  MS  0   0  1
  [27] .shstrtab         STRTAB          00000000 00103e 0000fc 00      0   0  1
  [28] .symtab           SYMTAB          00000000 0015ec 000410 10     29  45  4
  [29] .strtab           STRTAB          00000000 0019fc 0001f9 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
      [Requesting program interpreter: /lib/ld-linux.so.2]
  LOAD           0x000000 0x08048000 0x08048000 0x005e4 0x005e4 R E 0x1000
  LOAD           0x000f14 0x08049f14 0x08049f14 0x00100 0x00108 RW  0x1000
  DYNAMIC        0x000f28 0x08049f28 0x08049f28 0x000c8 0x000c8 RW  0x4
  NOTE           0x000168 0x08048168 0x08048168 0x00044 0x00044 R   0x4
  GNU_EH_FRAME   0x0004ec 0x080484ec 0x080484ec 0x00034 0x00034 R   0x4
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RW  0x4
  GNU_RELRO      0x000f14 0x08049f14 0x08049f14 0x000ec 0x000ec R   0x1

 Section to Segment mapping:
  Segment Sections...
   00
   01     .interp
   02     .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame_hdr .eh_frame
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss
   04     .dynamic
   05     .note.ABI-tag .note.gnu.build-id
   06     .eh_frame_hdr
   07
   08     .ctors .dtors .jcr .dynamic .got

Dynamic section at offset 0xf28 contains 20 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000c (INIT)                       0x80482b4
 0x0000000d (FINI)                       0x80484bc
 0x6ffffef5 (GNU_HASH)                   0x80481ac
 0x00000005 (STRTAB)                     0x804821c
 0x00000006 (SYMTAB)                     0x80481cc
 0x0000000a (STRSZ)                      76 (bytes)
 0x0000000b (SYMENT)                     16 (bytes)
 0x00000015 (DEBUG)                      0x0
 0x00000003 (PLTGOT)                     0x8049ff4
 0x00000002 (PLTRELSZ)                   24 (bytes)
 0x00000014 (PLTREL)                     REL
 0x00000017 (JMPREL)                     0x804829c
 0x00000011 (REL)                        0x8048294
 0x00000012 (RELSZ)                      8 (bytes)
 0x00000013 (RELENT)                     8 (bytes)
 0x6ffffffe (VERNEED)                    0x8048274
 0x6fffffff (VERNEEDNUM)                 1
 0x6ffffff0 (VERSYM)                     0x8048268
 0x00000000 (NULL)                       0x0

Relocation section '.rel.dyn' at offset 0x294 contains 1 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
08049ff0  00000206 R_386_GLOB_DAT    00000000   __gmon_start__

Relocation section '.rel.plt' at offset 0x29c contains 3 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0804a000  00000107 R_386_JUMP_SLOT   00000000   printf
0804a004  00000207 R_386_JUMP_SLOT   00000000   __gmon_start__
0804a008  00000307 R_386_JUMP_SLOT   00000000   __libc_start_main

There are no unwind sections in this file.

Symbol table '.dynsym' contains 5 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@GLIBC_2.0 (2)
     2: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.0 (2)
     4: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used

Symbol table '.symtab' contains 65 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 08048154     0 SECTION LOCAL  DEFAULT    1
     2: 08048168     0 SECTION LOCAL  DEFAULT    2
     3: 08048188     0 SECTION LOCAL  DEFAULT    3
     4: 080481ac     0 SECTION LOCAL  DEFAULT    4
     5: 080481cc     0 SECTION LOCAL  DEFAULT    5
     6: 0804821c     0 SECTION LOCAL  DEFAULT    6
     7: 08048268     0 SECTION LOCAL  DEFAULT    7
     8: 08048274     0 SECTION LOCAL  DEFAULT    8
     9: 08048294     0 SECTION LOCAL  DEFAULT    9
    10: 0804829c     0 SECTION LOCAL  DEFAULT   10
    11: 080482b4     0 SECTION LOCAL  DEFAULT   11
    12: 080482f0     0 SECTION LOCAL  DEFAULT   12
    13: 08048330     0 SECTION LOCAL  DEFAULT   13
    14: 080484bc     0 SECTION LOCAL  DEFAULT   14
    15: 080484d8     0 SECTION LOCAL  DEFAULT   15
    16: 080484ec     0 SECTION LOCAL  DEFAULT   16
    17: 08048520     0 SECTION LOCAL  DEFAULT   17
    18: 08049f14     0 SECTION LOCAL  DEFAULT   18
    19: 08049f1c     0 SECTION LOCAL  DEFAULT   19
    20: 08049f24     0 SECTION LOCAL  DEFAULT   20
    21: 08049f28     0 SECTION LOCAL  DEFAULT   21
    22: 08049ff0     0 SECTION LOCAL  DEFAULT   22
    23: 08049ff4     0 SECTION LOCAL  DEFAULT   23
    24: 0804a00c     0 SECTION LOCAL  DEFAULT   24
    25: 0804a014     0 SECTION LOCAL  DEFAULT   25
    26: 00000000     0 SECTION LOCAL  DEFAULT   26
    27: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    28: 08049f14     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_LIST__
    29: 08049f1c     0 OBJECT  LOCAL  DEFAULT   19 __DTOR_LIST__
    30: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_LIST__
    31: 08048360     0 FUNC    LOCAL  DEFAULT   13 __do_global_dtors_aux
    32: 0804a014     1 OBJECT  LOCAL  DEFAULT   25 completed.6086
    33: 0804a018     4 OBJECT  LOCAL  DEFAULT   25 dtor_idx.6088
    34: 080483c0     0 FUNC    LOCAL  DEFAULT   13 frame_dummy
    35: 00000000     0 FILE    LOCAL  DEFAULT  ABS crtstuff.c
    36: 08049f18     0 OBJECT  LOCAL  DEFAULT   18 __CTOR_END__
    37: 080485e0     0 OBJECT  LOCAL  DEFAULT   17 __FRAME_END__
    38: 08049f24     0 OBJECT  LOCAL  DEFAULT   20 __JCR_END__
    39: 08048490     0 FUNC    LOCAL  DEFAULT   13 __do_global_ctors_aux
    40: 00000000     0 FILE    LOCAL  DEFAULT  ABS a.c
    41: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_end
    42: 08049f28     0 OBJECT  LOCAL  DEFAULT   21 _DYNAMIC
    43: 08049f14     0 NOTYPE  LOCAL  DEFAULT   18 __init_array_start
    44: 08049ff4     0 OBJECT  LOCAL  DEFAULT   23 _GLOBAL_OFFSET_TABLE_
    45: 08048480     2 FUNC    GLOBAL DEFAULT   13 __libc_csu_fini
    46: 08048482     0 FUNC    GLOBAL HIDDEN    13 __i686.get_pc_thunk.bx
    47: 0804a00c     0 NOTYPE  WEAK   DEFAULT   24 data_start
    48: 00000000     0 FUNC    GLOBAL DEFAULT  UND printf@@GLIBC_2.0
    49: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
    50: 080484bc     0 FUNC    GLOBAL DEFAULT   14 _fini
    51: 08049f20     0 OBJECT  GLOBAL HIDDEN    19 __DTOR_END__
    52: 0804a00c     0 NOTYPE  GLOBAL DEFAULT   24 __data_start
    53: 00000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
    54: 0804a010     0 OBJECT  GLOBAL HIDDEN    24 __dso_handle
    55: 080484dc     4 OBJECT  GLOBAL DEFAULT   15 _IO_stdin_used
    56: 00000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@@GLIBC_
    57: 08048410    97 FUNC    GLOBAL DEFAULT   13 __libc_csu_init
    58: 0804a01c     0 NOTYPE  GLOBAL DEFAULT  ABS _end
    59: 08048330     0 FUNC    GLOBAL DEFAULT   13 _start
    60: 080484d8     4 OBJECT  GLOBAL DEFAULT   15 _fp_hw
    61: 0804a014     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
    62: 080483e4    40 FUNC    GLOBAL DEFAULT   13 main
    63: 00000000     0 NOTYPE  WEAK   DEFAULT  UND _Jv_RegisterClasses
    64: 080482b4     0 FUNC    GLOBAL DEFAULT   11 _init

Histogram for `.gnu.hash' bucket list length (total of 2 buckets):
 Length  Number     % of total  Coverage
      0  1          ( 50.0%)
      1  1          ( 50.0%)    100.0%

Version symbols section '.gnu.version' contains 5 entries:
 Addr: 0000000008048268  Offset: 0x000268  Link: 5 (.dynsym)
  000:   0 (*local*)       2 (GLIBC_2.0)     0 (*local*)       2 (GLIBC_2.0)
  004:   1 (*global*)

Version needs section '.gnu.version_r' contains 1 entries:
 Addr: 0x0000000008048274  Offset: 0x000274  Link: 6 (.dynstr)
  000000: Version: 1  File: libc.so.6  Cnt: 1
  0x0010:   Name: GLIBC_2.0  Flags: none  Version: 2

Notes at offset 0x00000168 with length 0x00000020:
  Owner                 Data size   Description
  GNU                  0x00000010   NT_GNU_ABI_TAG (ABI version tag)
    OS: Linux, ABI: 2.6.15

Notes at offset 0x00000188 with length 0x00000024:
  Owner                 Data size   Description
  GNU                  0x00000014   NT_GNU_BUILD_ID (unique build ID bitstring)
    Build ID: 17fb9651029b6a8543bfafec9eea23bd16454e65
</code></pre>
<h1 id="14-objdump-二进制文件分析">14. objdump 二进制文件分析</h1>
<p>objdump工具用来显示二进制文件的信息，就是以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。</p>
<h2 id="141-常用参数说明">14.1. 常用参数说明</h2>
<ul>
<li>-f 显示文件头信息</li>
<li>-D 反汇编所有section (-d反汇编特定section)</li>
<li>-h 显示目标文件各个section的头部摘要信息</li>
<li>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。</li>
<li>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</li>
<li>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。</li>
<li>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</li>
<li>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。</li>
<li>-t 显示文件的符号表入口。类似于nm -s提供的信息</li>
</ul>
<h2 id="142-示例">14.2. 示例</h2>
<p>查看本机目标结构（使用大端还是小端存储）:</p>
<pre><code>$objdump -i
</code></pre>
<p>反汇编程序:</p>
<pre><code>$objdump -d main.o
</code></pre>
<p>显示符号表入口:</p>
<pre><code>$objdump  -t main.o
</code></pre>
<p>希望显示可用的简洁帮助信息，直接输入objdump即可；（objdump -H)</p>
<h1 id="15-nm-目标文件格式分析">15. nm 目标文件格式分析</h1>
<p>nm 命令显示关于指定 File 中符号的信息，文件可以是对象文件、可执行文件或对象文件库。如果文件没有包含符号信息，nm 命令报告该情况，但不把它解释为出错条件。 nm 命令缺省情况下报告十进制符号表示法下的数字值。</p>
<pre><code>$nm myProgrammer
08049f28 d _DYNAMIC
08049ff4 d _GLOBAL_OFFSET_TABLE_
080484dc R _IO_stdin_used
         w _Jv_RegisterClasses
08049f18 d __CTOR_END__
08049f14 d __CTOR_LIST__
08049f20 D __DTOR_END__
08049f1c d __DTOR_LIST__
080485e0 r __FRAME_END__
08049f24 d __JCR_END__
08049f24 d __JCR_LIST__
0804a014 A __bss_start
0804a00c D __data_start
08048490 t __do_global_ctors_aux
08048360 t __do_global_dtors_aux
0804a010 D __dso_handle
         w __gmon_start__
08048482 T __i686.get_pc_thunk.bx
08049f14 d __init_array_end
08049f14 d __init_array_start
08048480 T __libc_csu_fini
08048410 T __libc_csu_init
         U __libc_start_main@@GLIBC_2.0
0804a014 A _edata
0804a01c A _end
080484bc T _fini
080484d8 R _fp_hw
080482b4 T _init
08048330 T _start
0804a014 b completed.6086
0804a00c W data_start
0804a018 b dtor_idx.6088
080483c0 t frame_dummy
080483e4 T main
         U printf@@GLIBC_2.0
</code></pre>
<p>这些包含可执行代码的段称为正文段。同样地，数据段包含了不可执行的信息或数据。另一种类型的段，称为 BSS 段，它包含以符号数据开头的块。对于 nm 命令列出的每个符号，它们的值使用十六进制来表示（缺省行为），并且在该符号前面加上了一个表示符号类型的编码字符。</p>
<p>可以将目标文件中所包含的不同的部分划分为段。段可以包含可执行代码、符号名称、初始数据值和许多其他类型的数据。有关这些类型的数据的详细信息，可以阅读 UNIX 中 nm 的 man 页面，其中按照该命令输出中的字符编码分别对每种类型进行了描述。</p>
<h2 id="151-选项说明">15.1. 选项说明</h2>
<ul>
<li>-a或–debug-syms：显示所有的符号，包括debugger-only symbols。</li>
<li>-B：等同于–format=bsd，用来兼容MIPS的nm。</li>
<li>-C或–demangle：将低级符号名解析(demangle)成用户级名字。这样可以使得C++函数名具有可读性。</li>
<li>–no-demangle：默认的选项，不需要将低级符号名解析成用户级名。</li>
<li>-D或–dynamic：显示动态符号。该任选项仅对于动态目标(例如特定类型的共享库)有意义。</li>
<li>-f format：使用format格式输出。format可以选取bsd、sysv或posix，该选项在GNU的nm中有用。默认为bsd。</li>
<li>-g或–extern-only：仅显示外部符号。</li>
<li>-n、-v或–numeric-sort：按符号对应地址的顺序排序，而非按符号名的字符顺序。</li>
<li>-p或–no-sort：按目标文件中遇到的符号顺序显示，不排序。</li>
<li>-P或–portability：使用POSIX.2标准输出格式代替默认的输出格式。等同于使用任选项-f posix。</li>
<li>-s或–print-armap：当列出库中成员的符号时，包含索引。索引的内容包含：哪些模块包含哪些名字的映射。</li>
<li>-r或–reverse-sort：反转排序的顺序(例如，升序变为降序)。</li>
<li>–size-sort：按大小排列符号顺序。该大小是按照一个符号的值与它下一个符号的值进行计算的。</li>
<li>–target=bfdname：指定一个目标代码的格式，而非使用系统的默认格式。</li>
<li>-u或–undefined-only：仅显示没有定义的符号(那些外部符号)。</li>
<li>–defined-only:仅显示定义的符号。</li>
<li>-l或–line-numbers：对每个符号，使用调试信息来试图找到文件名和行号。</li>
<li>-V或–version：显示nm的版本号。</li>
<li>–help：显示nm的选项。</li>
</ul>
<h2 id="152-符号说明">15.2. 符号说明</h2>
<p>对于每一个符号来说，其类型如果是小写的，则表明该符号是local的；大写则表明该符号是global(external)的。</p>
<ul>
<li>
<p>A 该符号的值是绝对的，在以后的链接过程中，不允许进行改变。这样的符号值，常常出现在中断向量表中，例如用符号来表示各个中断向量函数在中断向量表中的位置。</p>
</li>
<li>
<p>B 该符号的值出现在非初始化数据段(bss)中。例如，在一个文件中定义全局static int test。则该符号test的类型为b，位于bss section中。其值表示该符号在bss段中的偏移。一般而言，bss段分配于RAM中。</p>
</li>
<li>
<p>C 该符号为common。common symbol是未初始话数据段。该符号没有包含于一个普通section中。只有在链接过程中才进行分配。符号的值表示该符号需要的字节数。例如在一个c文件中，定义int test，并且该符号在别的地方会被引用，则该符号类型即为C。否则其类型为B。</p>
</li>
<li>
<ul>
<li>
<p>D 该符号位于初始化数据段中。一般来说，分配到data section中。</p>
<p>例如：定义全局int baud_table[5] = {9600, 19200, 38400, 57600, 115200}，会分配到初始化数据段中。</p>
</li>
</ul>
</li>
<li>
<p>G 该符号也位于初始化数据段中。主要用于small object提高访问small data object的一种方式。</p>
</li>
<li>
<p>I 该符号是对另一个符号的间接引用。</p>
</li>
<li>
<p>N 该符号是一个debugging符号。</p>
</li>
<li>
<ul>
<li>
<p>R 该符号位于只读数据区。</p>
<p>例如定义全局const int test[] = {123, 123};则test就是一个只读数据区的符号。值得注意的是，如果在一个函数中定义const char <a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html#id4">*</a>test = “abc”, const char test_int = 3。使用nm都不会得到符号信息，但是字符串”abc”分配于只读存储器中，test在rodata section中，大小为4。</p>
</li>
</ul>
</li>
<li>
<p>S 符号位于非初始化数据区，用于small object。</p>
</li>
<li>
<p>T 该符号位于代码区text section。</p>
</li>
<li>
<ul>
<li>
<p>U 该符号在当前文件中是未定义的，即该符号的定义在别的文件中。</p>
<p>例如，当前文件调用另一个文件中定义的函数，在这个被调用的函数在当前就是未定义的；但是在定义它的文件中类型是T。但是对于全局变量来说，在定义它的文件中，其符号类型为C，在使用它的文件中，其类型为U。</p>
</li>
</ul>
</li>
<li>
<p>V 该符号是一个weak object。</p>
</li>
<li>
<p>W The symbol is a weak symbol that has not been specifically tagged as a weak object symbol.</p>
</li>
<li>
<p>? 该符号类型没有定义</p>
</li>
</ul>
<p><em>库或对象名</em> 如果您指定了 -A 选项，则 nm 命令只报告与该文件有关的或者库或者对象名。</p>
<h2 id="153-示例">15.3. 示例</h2>
<ol>
<li>寻找特殊标识</li>
</ol>
<p>有时会碰到一个编译了但没有链接的代码，那是因为它缺失了标识符；这种情况，可以用nm和objdump、readelf命令来查看程序的符号表；所有这些命令做的工作基本一样；</p>
<p>比如连接器报错有未定义的标识符；大多数情况下，会发生在库的缺失或企图链接一个错误版本的库的时候；浏览目标代码来寻找一个特殊标识符的引用:</p>
<pre><code>nm -uCA *.o | grep foo
</code></pre>
<p>-u选项限制了每个目标文件中未定义标识符的输出。-A选项用于显示每个标识符的文件名信息；对于C++代码，常用的还有-C选项，它也为解码这些标识符；</p>
<p>注解</p>
<p>objdump、readld命令可以完成同样的任务。等效命令为： $objdump -t $readelf -s</p>
<ol>
<li>
<p>列出 a.out 对象文件的静态和外部符:</p>
<pre><code>$nm -e a.out
</code></pre>
</li>
<li>
<p>以十六进制显示符号大小和值并且按值排序符号:</p>
<pre><code>$nm -xv a.out
</code></pre>
</li>
<li>
<p>显示 libc.a 中所有 64 位对象符号，忽略所有 32 位对象:</p>
<pre><code>$nm -X64 /usr/lib/libc.a
</code></pre>
</li>
</ol>
<h1 id="16-size-查看程序内存映像大小">16. size 查看程序内存映像大小</h1>
<p>作用：查看程序被映射到内存中的映像所占用的大小信息。</p>
<p>程序映射到内存中，从低地址到高地址依次为下列段:</p>
<ul>
<li>代码段： 只读，可共享; 代码段（code segment/text segment ）通常是指用来存放程序执行代码的一块内存区域。这部分区域的大小在程序运行前就已经确定，并且内存区域通常属于只读, 某些架构也允许代码段为可写，即允许修改程序。在代码段中，也有可能包含一些只读的常数变量，例如字符串常量等。</li>
<li>数据段： 储存已被初始化了的静态数据。数据段（data segment ）通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li>
<li>BSS 段：未初始化的数据段. BSS 段（bss segment ）通常是指用来存放程序中未初始化的全局变量的一块内存区域。BSS 是英文Block Started by Symbol 的简称。BSS 段属于静态内存分配。</li>
<li>堆（heap ）： 堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc 等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free 等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）</li>
<li>栈(stack) ：栈又称堆栈，是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{} ”中定义的变量（但不包括static 声明的变量，static 意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/ 恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。</li>
</ul>
<p>另外, 在高地址还储存了命令行参数及环境变量.</p>
<p>因为内存程序映像中的各段可能位于不同的地址空间中, 它们不一定位于连续的内存块中. 操作系统将程序映像映射到地址空间时, 通常将内存程序映像划分为大小相同的块(也就是page, 页). 只有该页被引用时, 它才被加载到内存中. 不过对于程序员来说, 可以视内存程序映像在逻辑上是连续的.</p>
<pre><code>/opt/app/todeav1/colin/tests#size main
text    data     bss     dec     hex filename
1259     540      16    1815     717 main
</code></pre>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux Development Environment Deployment]]></title>
        <id>https://jingwoo.github.io/post/linux-development-environment-deployment/</id>
        <link href="https://jingwoo.github.io/post/linux-development-environment-deployment/">
        </link>
        <updated>2020-07-28T08:19:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="usage">Usage</h2>
<pre><code class="language-bash">➜  linux_environment git:(master) ✗ ./setup.bash --help
=================================================================================================
        ███████╗███╗   ██╗██╗   ██╗    ██████╗ ███████╗██████╗ ██╗      ██████╗ ██╗   ██╗
        ██╔════╝████╗  ██║██║   ██║    ██╔══██╗██╔════╝██╔══██╗██║     ██╔═══██╗╚██╗ ██╔╝
        █████╗  ██╔██╗ ██║██║   ██║    ██║  ██║█████╗  ██████╔╝██║     ██║   ██║ ╚████╔╝
        ██╔══╝  ██║╚██╗██║╚██╗ ██╔╝    ██║  ██║██╔══╝  ██╔═══╝ ██║     ██║   ██║  ╚██╔╝
        ███████╗██║ ╚████║ ╚████╔╝     ██████╔╝███████╗██║     ███████╗╚██████╔╝   ██║
        ╚══════╝╚═╝  ╚═══╝  ╚═══╝      ╚═════╝ ╚══════╝╚═╝     ╚══════╝ ╚═════╝    ╚═╝
=================================================================================================
Usage: ./setup.bash [options]
Configure development environment for linux system
Options:
    -d, --distribution       linux distribution ([debian|redhat] series)
    -u, --username           set user name for git
    -e, --email              set email for git
    -p, --password           password for root
    -h, --help               Script help information
</code></pre>
<h3 id="example">example</h3>
<pre><code class="language-bash">./setup.sh -d ubuntu -u username -e xxx@email.com -p password
</code></pre>
<h2 id="script">Script</h2>
<pre><code class="language-bash">#!/bin/bash
#
# Configure development environment for linux system

# set -euxo pipefail

distro=&quot;fedora&quot;
# for git configuration
username=&quot;&quot;
email=&quot;&quot;
# for automation
password=&quot;&quot;

function info() {
  echo &quot;[$(date +'%Y-%m-%dT%H:%M:%S%z')]: $@&quot; &gt;&amp;2
}

function auto()
{
	expect_file=$(mktemp /tmp/expect-script.XXXXXX)
	cat &gt; ${expect_file} &lt;&lt; EOF
set timeout -1
match_max 100000
spawn $@
expect -exact &quot;password&quot;
send -- &quot;${password}\r&quot;
expect eof
EOF
	expect -f ${expect_file}
	rm -rf ${expect_file}
}

function install_automation_tool()
{
	which expect
	if [[ $? -eq 0 ]]; then
		return
	fi

	if [[ ${distro} == &quot;ubuntu&quot; ]] || [[ ${distro} == &quot;debian&quot; ]]; then
		sudo apt update  -y
		sudo apt install -y expect
	elif [[ ${distro} == &quot;fedora&quot; ]] || [[ ${distro} == &quot;centos&quot; ]]; then
		sudo dnf upgrade -y
		sudo dnf install -y expect
	else
		echo &quot;Unsupport other linux distro other than debian and redhat series&quot;
	fi
}

function install_common_tools_for_debian_series()
{
	auto sudo apt update  -y
	auto sudo apt upgrade -y

	auto sudo apt install -y silversearcher-ag fd-find bat ccze git tig cmatrix screenfetch universal-ctags
	auto sudo apt install -y fzf glances tmux shellcheck ranger aria2 axel cloc taskwarrior jq zsh npm
	auto sudo apt install -y neovim cscope global python3-pip ca-certificates gdebi

	auto sudo apt install -y build-essential nodejs golang clangd ruby-dev clang llvm
	auto sudo apt install -y manpages-dev man-db manpages-posix-dev
	auto sudo apt install -y libtool automake autoconf cmake pkgconf cmake
	auto sudo apt install -y valgrind gdb gdbserver tcpdump systemtap ltrace strace
}

function install_common_tools_for_redhat_series()
{
	auto sudo dnf upgrade -y

	auto sudo dnf install -y the_silver_searcher fd-find bat exa ccze git tig cmatrix screenfetch ctags 
	auto sudo dnf install -y fzf glances tmux ShellCheck ranger aria2 axel cloc task jq zsh npm
	auto sudo dnf install -y neovim cscope global python3-pip ca-certificates

	auto dnf install -y nodejs golang clang llvm ruby-devel
	auto dnf install -y valgrind gdb gdb-gdbserver tcpdump systemtap ltrace strace
	auto dnf group install -y 'Development Tools' 
	auto dnf install -y gcc gcc-c++ rpm-build rpm-devel rpmlint make python bash coreutils diffutils patch rpmdevtools
}

function install_common_tools()
{
	if [[ ${distro} == &quot;ubuntu&quot; ]] || [[ ${distro} == &quot;debian&quot; ]]; then
		install_common_tools_for_debian_series
	elif [[ ${distro} == &quot;fedora&quot; ]] || [[ ${distro} == &quot;centos&quot; ]]; then
		install_common_tools_for_redhat_series
	else
		echo &quot;Unsupport other linux distro other than debian and redhat series&quot;
	fi
}

function write_git_commit_template()
{
	cat &lt;&lt; EOF &gt; ${1}
# [&lt;tag&gt;] (If applied, this commit will...) &lt;subject&gt; (Max 72 char)
# |&lt;----   Preferably using up to 50 chars   ---&gt;|&lt;-------------------&gt;|
# Example:
# [feat] Implement automated commit messages

# (Optional) Explain why this change is being made
# |&lt;----   Try To Limit Each Line to a Maximum Of 72 Characters   ----&gt;|

# (Optional) Provide links or keys to any relevant tickets, articles or other resources
# Example: Github issue #23

# --- COMMIT END ---
# Tag can be 
#    feat     (new feature)
#    fix      (bug fix)
#    refactor (refactoring code)
#    style    (formatting, missing semi colons, etc; no code change)
#    doc      (changes to documentation)
#    test     (adding or refactoring tests; no production code change)
#    version  (version bump/new release; no production code change)
#    jsrXXX   (Patches related to the implementation of jsrXXX, where XXX the JSR number)
#    jdkX     (Patches related to supporting jdkX as the host VM, where X the JDK version)
#    dbg      (Changes in debugging code/frameworks; no production code change)
#    license  (Edits regarding licensing; no production code change)
#    hack     (Temporary fix to make things move forward; please avoid it)
#    WIP      (Work In Progress; for intermediate commits to keep patches reasonably sized)
#    defaults (changes default options)
#
# Note: Multiple tags can be combined, e.g. [fix][jsr292] Fix issue X with methodhandles
# --------------------
# Remember to:
#   * Capitalize the subject line
#   * Use the imperative mood in the subject line
#   * Do not end the subject line with a period
#   * Separate subject from body with a blank line
#   * Use the body to explain what and why vs. how
#   * Can use multiple lines with &quot;-&quot; or &quot;*&quot; for bullet points in body
# --------------------
EOF
}

function configure_git_diff()
{
	# npm config get registry

	auto sudo npm config set registry https://registry.npm.taobao.org
	auto sudo npm install -g diff-so-fancy

	git config --global core.pager &quot;diff-so-fancy | less --tabs=4 -RFX&quot;
	git config --global color.ui true
	git config --global color.diff-highlight.oldNormal    &quot;red bold&quot;
	git config --global color.diff-highlight.oldHighlight &quot;red bold 52&quot;
	git config --global color.diff-highlight.newNormal    &quot;green bold&quot;
	git config --global color.diff-highlight.newHighlight &quot;green bold 22&quot;

	git config --global color.diff.meta       &quot;11&quot;
	git config --global color.diff.frag       &quot;magenta bold&quot;
	git config --global color.diff.commit     &quot;yellow bold&quot;
	git config --global color.diff.old        &quot;red bold&quot;
	git config --global color.diff.new        &quot;green bold&quot;
	git config --global color.diff.whitespace &quot;red reverse&quot;
	git config --bool --global diff-so-fancy.markEmptyLines false
	git config --bool --global diff-so-fancy.changeHunkIndicators false
	git config --bool --global diff-so-fancy.stripLeadingSymbols false
	git config --bool --global diff-so-fancy.useUnicodeRuler false
	# git log's commit header width
	git config --global diff-so-fancy.rulerWidth 47
}

function configure_git()
{
	git config --global user.name ${username}
	git config --global user.email ${email}
	git config --global http.sslVerify false
	git config --global core.editor nvim
	# for mac or linux
	git config --global core.autocrlf input
	# for windows
	# git config --global core.autocrlf false

	write_git_commit_template ~/.git-commit-template.txt
	git config --global commit.template ~/.git-commit-template.txt

	configure_git_diff
}

function auto_install_zsh()
{
	expect_file=$(mktemp /tmp/expect-script.XXXXXX)
	cat &gt; ${expect_file} &lt;&lt; EOF
set timeout -1
match_max 100000
spawn $@
expect -exact &quot;Y/n&quot;
send &quot;Y\r&quot;
expect -exact &quot;Password&quot;
send -- &quot;${password}\r&quot;
expect eof
EOF
	expect -f ${expect_file}
	rm -rf ${expect_file}
}

function configure_terminal()
{
	# terminal configuration
	if [[ -d ~/.oh-my-zsh ]]; then
		rm -rf ~/.oh-my-zsh
	fi

	wget --no-check-certificate https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -O on-my-zsh-install.sh
	if [[ $? -ne 0 ]]; then
		curl -fksSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh -o on-my-zsh-install.sh
	fi

	auto_install_zsh sh on-my-zsh-install.sh 
	rm -rf on-my-zsh-install.sh
	git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
	git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
	git clone https://github.com/zsh-users/zsh-history-substring-search ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-history-substring-search
	git clone https://github.com/chrissicool/zsh-256color ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-256color
	sed -i 's/fg=8/fg=3/g' ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
	sed -i 's/plugins=(git)/plugins=(git zsh-autosuggestions extract zsh-syntax-highlighting history-substring-search history zsh-256color vi-mode z wd taskwarrior)/g' ~/.zshrc
	cat &lt;&lt; EOF &gt;&gt; ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-history-substring-search/zsh-history-substring-search.zsh
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down
EOF
}

function alias_vim()
{
	cat &lt;&lt; EOF &gt;&gt; ~/.zshrc
alias vi='nvim'
alias vim='nvim'
EOF
}

function configure_npm_source()
{
	mkdir -p ~/.pip
	cat &lt;&lt; EOF &gt; ~/.pip/pip.conf
[global]
index-url = https://mirrors.aliyun.com/pypi/simple
EOF
}

function language_support_vim()
{
  	configure_npm_source
	npm config set registry https://registry.npm.taobao.org
	yarn config set registry https://registry.npm.taobao.org
	gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/
	auto sudo npm install --global yarn

	# curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py
	axel -n 5 https://bootstrap.pypa.io/get-pip.py
	auto sudo python2 get-pip.py
	rm get-pip.py
	auto sudo pip2 install --no-cache-dir --upgrade --force-reinstall neovim # -i https://pypi.tuna.tsinghua.edu.cn/simple
	auto sudo pip3 install --no-cache-dir --upgrade --force-reinstall neovim # -i https://pypi.tuna.tsinghua.edu.cn/simple
	auto sudo npm install -g neovim
	auto sudo gem install neovim
}

function customize_spacevim_configuration()
{
	if [[ -f ~/.SpaceVim.d/init.toml ]]; then
		mv ~/.SpaceVim.d/init.toml ~/.SpaceVim.d/init.toml.bak
	fi
	mkdir -p ~/.SpaceVim.d
	cat &lt;&lt; EOF &gt; ~/.SpaceVim.d/init.toml
[options]
    # set spacevim theme. by default colorscheme layer is not loaded,
    # if you want to use more colorscheme, please load the colorscheme
    # layer
    # colorscheme = &quot;gruvbox&quot;
    colorscheme = &quot;NeoSolarized&quot;
    colorscheme_bg = &quot;dark&quot;
    # Disable guicolors in basic mode, many terminal do not support 24bit
    # true colors
    enable_guicolors = true
    # Disable statusline separator, if you want to use other value, please
    # install nerd fonts
    statusline_separator = &quot;arrow&quot;
    statusline_inactive_separator = &quot;bar&quot;
    buffer_index_type = 4
    windows_index_type = 3
    enable_statusline_mode = true
     # left sections of statusline
    statusline_left_sections = [
       'winnr',
       'major mode',
       'filename',
       'fileformat',
       'minor mode lighters',
       'version control info',
       'search status'
    ]
    # right sections of statusline
    statusline_right_sections = [
       'cursorpos',
       'percentage',
       'input method',
       'date',
       'time'
    ]

    enable_tabline_filetype_icon = true
    enable_statusline_display_mode = true
    statusline_unicode_symbols = true
    realtime_leader_guide = 1
    enable_statusline_tag = true
    # Enable vim compatible mode, avoid changing origin vim key bindings
    vimcompatible = true
    automatic_update = true
    enable_neomake = false
    filemanager = &quot;defx&quot;

[[custom_plugins]]
	name = 'neoclide/coc.nvim'
	merge = 0
	build =  'yarn install --frozen-lockfile'
	# branch = 'release'

[[layers]]
	name = 'shell'
	default_position = 'right'

[[layers]]
	name = &quot;VersionControl&quot;
	enable-gtm-status = true

[[layers]]
	name = &quot;checkers&quot;
	show_cursor_error = false

[[layers]]
	name = &quot;colorscheme&quot;

[[layers]]
	name = &quot;git&quot;
	git-plugin = &quot;fugitive&quot;

[[layers]]
	name = &quot;tmux&quot;

[[layers]]
	name = &quot;leaderf&quot;

[[layers]]
	name = &quot;sudo&quot;

[[layers]]
	name = &quot;tags&quot;

[[layers]]
	name = &quot;tools&quot;

[[layers]]
	name = 'core'
EOF
}

function configure_init_vim()
{
	cat &lt;&lt; EOF &gt;&gt; ~/.SpaceVim/init.vim
set tabstop=4
set expandtab
set shiftwidth=4
nnoremap &lt;F9&gt; :set invpaste paste?&lt;CR&gt;
set pastetoggle=&lt;F9&gt;
set showmode
set cmdheight=1

let g:coc_global_extensions = ['coc-json','coc-clangd','coc-cmake','coc-explorer','coc-fzf-preview','coc-python','coc-spell-checker','coc-template','coc-go']
&quot; let g:EasyMotion_do_mapping = 1

&quot; filetype plugin indent on
&quot; syntax enable
&quot;
&quot; Default value is &quot;normal&quot;, Setting this option to &quot;high&quot; or &quot;low&quot; does use the
&quot; same Solarized palette but simply shifts some values up or down in order to
&quot; expand or compress the tonal range displayed.
let g:neosolarized_contrast = &quot;normal&quot;

&quot; Special characters such as trailing whitespace, tabs, newlines, when displayed
&quot; using &quot;:set list&quot; can be set to one of three levels depending on your needs.
&quot; Default value is &quot;normal&quot;. Provide &quot;high&quot; and &quot;low&quot; options.
let g:neosolarized_visibility = &quot;normal&quot;

&quot; I make vertSplitBar a transparent background color. If you like the origin
&quot; solarized vertSplitBar style more, set this value to 0.
let g:neosolarized_vertSplitBgTrans = 1

&quot; If you wish to enable/disable NeoSolarized from displaying bold, underlined
&quot; or italicized&quot; typefaces, simply assign 1 or 0 to the appropriate variable.
&quot; Default values:
let g:neosolarized_bold = 1
let g:neosolarized_underline = 1
let g:neosolarized_italic = 0

&quot; Used to enable/disable &quot;bold as bright&quot; in Neovim terminal. If colors of bold
&quot; text output by commands like `ls` aren't what you expect, you might want to
&quot; try disabling this option. Default value:
let g:neosolarized_termBoldAsBright = 1

&quot; TextEdit might fail if hidden is not set.
set hidden

&quot; Some servers have issues with backup files, see #649.
set nobackup
set nowritebackup

&quot; Give more space for displaying messages.
set cmdheight=2

&quot; Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable
&quot; delays and poor user experience.
set updatetime=300

&quot; Don't pass messages to |ins-completion-menu|.
set shortmess+=c

&quot; Always show the signcolumn, otherwise it would shift the text each time
&quot; diagnostics appear/become resolved.
if has(&quot;patch-8.1.1564&quot;)
  &quot; Recently vim can merge signcolumn and number column into one
  set signcolumn=number
else
  set signcolumn=yes
endif

&quot; Use tab for trigger completion with characters ahead and navigate.
&quot; NOTE: Use command ':verbose imap &lt;tab&gt;' to make sure tab is not mapped by
&quot; other plugin before putting this into your config.
inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;
      \ pumvisible() ? &quot;\&lt;C-n&gt;&quot; :
      \ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :
      \ coc#refresh()
inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-h&gt;&quot;

function! s:check_back_space() abort
  let col = col('.') - 1
  return !col || getline('.')[col - 1]  =~# '\s'
endfunction

&quot; Use &lt;c-space&gt; to trigger completion.
if has('nvim')
  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-space&gt; coc#refresh()
else
  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-@&gt; coc#refresh()
endif

&quot; Use &lt;cr&gt; to confirm completion, `&lt;C-g&gt;u` means break undo chain at current
&quot; position. Coc only does snippet and additional edit on confirm.
&quot; &lt;cr&gt; could be remapped by other vim plugin, try `:verbose imap &lt;CR&gt;`.
if exists('*complete_info')
  inoremap &lt;expr&gt; &lt;cr&gt; complete_info()[&quot;selected&quot;] != &quot;-1&quot; ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;
else
  inoremap &lt;expr&gt; &lt;cr&gt; pumvisible() ? &quot;\&lt;C-y&gt;&quot; : &quot;\&lt;C-g&gt;u\&lt;CR&gt;&quot;
endif

&quot; Use `[g` and `]g` to navigate diagnostics
&quot; Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.
nmap &lt;silent&gt; [g &lt;Plug&gt;(coc-diagnostic-prev)
nmap &lt;silent&gt; ]g &lt;Plug&gt;(coc-diagnostic-next)

&quot; GoTo code navigation.
nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)
nmap &lt;silent&gt; gy &lt;Plug&gt;(coc-type-definition)
nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)
nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)

&quot; Use K to show documentation in preview window.
nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;

function! s:show_documentation()
  if (index(['vim','help'], &amp;filetype) &gt;= 0)
    execute 'h '.expand('&lt;cword&gt;')
  else
    call CocAction('doHover')
  endif
endfunction

&quot; Highlight the symbol and its references when holding the cursor.
autocmd CursorHold * silent call CocActionAsync('highlight')

&quot; Symbol renaming.
nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)

&quot; Formatting selected code.
xmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)
nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)

augroup mygroup
  autocmd!
  &quot; Setup formatexpr specified filetype(s).
  autocmd FileType typescript,json setl formatexpr=CocAction('formatSelected')
  &quot; Update signature help on jump placeholder.
  autocmd User CocJumpPlaceholder call CocActionAsync('showSignatureHelp')
augroup end

&quot; Applying codeAction to the selected region.
&quot; Example: `&lt;leader&gt;aap` for current paragraph
xmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)
nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)

&quot; Remap keys for applying codeAction to the current buffer.
nmap &lt;leader&gt;ac  &lt;Plug&gt;(coc-codeaction)
&quot; Apply AutoFix to problem on the current line.
nmap &lt;leader&gt;qf  &lt;Plug&gt;(coc-fix-current)

&quot; Map function and class text objects
&quot; NOTE: Requires 'textDocument.documentSymbol' support from the language server.
xmap if &lt;Plug&gt;(coc-funcobj-i)
omap if &lt;Plug&gt;(coc-funcobj-i)
xmap af &lt;Plug&gt;(coc-funcobj-a)
omap af &lt;Plug&gt;(coc-funcobj-a)
xmap ic &lt;Plug&gt;(coc-classobj-i)
omap ic &lt;Plug&gt;(coc-classobj-i)
xmap ac &lt;Plug&gt;(coc-classobj-a)
omap ac &lt;Plug&gt;(coc-classobj-a)

&quot; Use CTRL-S for selections ranges.
&quot; Requires 'textDocument/selectionRange' support of LS, ex: coc-tsserver
nmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)
xmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)

&quot; Add `:Format` command to format current buffer.
command! -nargs=0 Format :call CocAction('format')

&quot; Add `:Fold` command to fold current buffer.
command! -nargs=? Fold :call     CocAction('fold', &lt;f-args&gt;)

&quot; Add `:OR` command for organize imports of the current buffer.
command! -nargs=0 OR   :call     CocAction('runCommand', 'editor.action.organizeImport')

&quot; Add (Neo)Vim's native statusline support.
&quot; NOTE: Please see `:h coc-status` for integrations with external plugins that
&quot; provide custom statusline: lightline.vim, vim-airline.
set statusline^=%{coc#status()}%{get(b:,'coc_current_function','')}

&quot; Mappings for CoCList
&quot; Show all diagnostics.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;a  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;
&quot; Manage extensions.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;e  :&lt;C-u&gt;CocList extensions&lt;cr&gt;
&quot; Show commands.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;c  :&lt;C-u&gt;CocList commands&lt;cr&gt;
&quot; Find symbol of current document.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;o  :&lt;C-u&gt;CocList outline&lt;cr&gt;
&quot; Search workspace symbols.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;s  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;
&quot; Do default action for next item.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;j  :&lt;C-u&gt;CocNext&lt;CR&gt;
&quot; Do default action for previous item.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;k  :&lt;C-u&gt;CocPrev&lt;CR&gt;
&quot; Resume latest coc list.
nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;p  :&lt;C-u&gt;CocListResume&lt;CR&gt;
EOF
}

function set_background_translucent()
{
	cat &lt;&lt; EOF &gt;&gt; ${HOME}/.SpaceVim/config/init.vim
func! s:transparent_background()
    highlight Normal guibg=None ctermbg=None
    highlight NonText guibg=None ctermbg=None
endf
autocmd ColorScheme * call s:transparent_background()
EOF
}

function install_spacevim()
{
	curl -sLf https://spacevim.org/install.sh | bash -s -- --install neovim
	customize_spacevim_configuration
	configure_init_vim
	set_background_translucent
}

function configure_coc_plugins()
{
	echo &quot;TODO: coc&quot;
	# Reference:
	# https://github.com/neoclide/coc.nvim
	# https://github.com/neoclide/coc.nvim/wiki
	# https://clangd.llvm.org/
	#
	# cd ~/.cache/vimfiles/repos/github.com/neoclide/coc.nvim
	# git clean -xfd
	# yarn install --frozen-lockfile
	# coc-clangd coc-cmake coc-sh coc-go coc-python coc-explorer coc-highlight 
	rm -rf $(find ~ -name 'deoplete*')
	sed -i &quot;s/let g:spacevim_autocomplete_method = 'deoplete'/let g:spacevim_autocomplete_method = 'coc'/g&quot; ${HOME}/.SpaceVim/autoload/SpaceVim.vim
}

function configure_vim()
{
	# vim configuration
	alias_vim
	language_support_vim
	install_spacevim
	configure_coc_plugins
}

function customize_fzf_configuration()
{
	cat &lt;&lt; EOF &gt;&gt; ~/.zshrc
alias fd=fdfind
export FZF_DEFAULT_COMMAND='fd --hidden --follow -E &quot;.git&quot; -E &quot;node_modules&quot; . /etc /home'
export FZF_DEFAULT_OPTS='--height 90% --layout=reverse --bind=alt-j:down,alt-k:up,alt-i:toggle+down --border --preview &quot;(bat --style=numbers --color=always {}) 2&gt; /dev/null | head -500&quot; --preview-window=down'

# Use ~~ as the trigger sequence instead of the default **
export FZF_COMPLETION_TRIGGER='~~'

# Options to fzf command
export FZF_COMPLETION_OPTS='+c -x'

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
_fzf_compgen_path() {
	fd --hidden --follow --exclude &quot;.git&quot; . &quot;$1&quot;
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
	fd --type d --hidden --follow --exclude &quot;.git&quot; . &quot;$1&quot;
}

# (EXPERIMENTAL) Advanced customization of fzf options via _fzf_comprun function
# - The first argument to the function is the name of the command.
# - You should make sure to pass the rest of the arguments to fzf.
_fzf_comprun() {
  local command=$1
  shift

  case &quot;$command&quot; in
    cd)           fzf &quot;$@&quot; --preview 'tree -C {} | head -200' ;;
    export|unset) fzf &quot;$@&quot; --preview &quot;eval 'echo \$'{}&quot; ;;
    ssh)          fzf &quot;$@&quot; --preview 'dig {}' ;;
    *)            fzf &quot;$@&quot; ;;
  esac
}
EOF
}

function configure_fzf()
{
	# set command-line fuzzer finder
	rm -rf ~/.fzf
	git clone --depth 1 https://github.com/junegunn/fzf.git ~/.fzf
	alias curl='curl -k'
	expect_file=$(mktemp /tmp/expect-script.XXXXXX)
	cat &gt; ${expect_file} &lt;&lt; EOF
set timeout -1
match_max 100000
spawn bash ${HOME}/.fzf/install
expect -exact &quot;\[y\]/n&quot;
send -- &quot;y\r&quot;
expect -exact &quot;\[y\]/n&quot;
send -- &quot;y\r&quot;
expect -exact &quot;\[y\]/n&quot;
send -- &quot;y\r&quot;
expect eof
EOF
	expect -f ${expect_file}
	rm -rf ${expect_file}
	customize_fzf_configuration
}

function support_true_color_for_terminal()
{
	# terminal true-color support
	if [[ $(tput colors) -ne 256 ]]; then
		cat &lt;&lt; EOF &gt;&gt; /etc/profile
case &quot;$TERM&quot; in
	xterm)
		export TERM=xterm-256color
		;;
	screen)
		export TERM=screen-256color
		;;
esac
EOF
	fi

	awk 'BEGIN{
	    s=&quot;/\\/\\/\\/\\/\\&quot;; s=s s s s s s s s;
	    for(colnum=0; colnum&lt;77; colnum++) {
		r = 255-(colnum*255/76);
		g = (colnum*510/76);
		b = (colnum*255/76);
		if (g&gt;255) g = 510-g;
		printf &quot;\033[48;2;%d;%d;%dm&quot;, r,g,b;
		printf &quot;\033[38;2;%d;%d;%dm&quot;, 255-r,255-g,255-b;
		printf &quot;%s\033[0m&quot;, substr(s,colnum+1,1);
	    }
	    printf &quot;\n&quot;;
	}'

	for T in $(find /usr/share/terminfo -type f -printf '%f '); do echo &quot;$T $(tput -T $T colors)&quot;; done | sort -nk2 | tail -n20
}

function configure_tmux()
{
	# tmux configuration
	cd ${HOME}
	rm -rf ${HOME}/.tmux
	git clone https://github.com/gpakosz/.tmux.git ${HOME}/.tmux
	rm -rf ${HOME}/.tmux.conf
	ln -s -f ${HOME}/.tmux/.tmux.conf
	rm -rf ${HOME}/.tmux.conf.local
	cp ${HOME}/.tmux/.tmux.conf.local .
	echo &quot;export EDITOR='vim'&quot; &gt;&gt; ~/.zshrc

	auto sudo gem install tmuxinator
	
	cd ${HOME}/.tmux
	mkdir plugins
	git clone https://github.com/tmux-plugins/tmux-resurrect.git
	cd ${HOME}/.tmux/plugins
	git clone https://github.com/tmux-plugins/tmux-continuum.git

	rm -rf ~/.bin/.tmuxinator.zsh
	echo &quot;source ~/.bin/.tmuxinator.zsh&quot; &gt;&gt; ${HOME}/.zshrc
	mkdir -p ${HOME}/.bin
	# should escaping \$
	cat &lt;&lt; EOF &gt; ${HOME}/.bin/.tmuxinator.zsh
#compdef _tmuxinator tmuxinator

_tmuxinator() {
  local commands projects
  commands=(\${(f)&quot;\$(tmuxinator commands zsh)&quot;})
  projects=(\${(f)&quot;\$(tmuxinator completions start)&quot;})

  if (( CURRENT == 2 )); then
    _alternative \
      'commands:: _describe -t commands &quot;tmuxinator subcommands&quot; commands' \
      'projects:: _describe -t projects &quot;tmuxinator projects&quot; projects'
  elif (( CURRENT == 3)); then
    case \$words[2] in
      copy|cp|c|debug|delete|rm|open|o|start|s|edit|e)
        _arguments '*:projects:(\$projects)'
      ;;
    esac
  fi

  return
}

complete -F _tmuxinator tmuxinator mux
alias mux=&quot;tmuxinator&quot;
# Local Variables:
# mode: Shell-Script
# sh-indentation: 2
# indent-tabs-mode: nil
# sh-basic-offset: 2
# End:
# vim: ft=zsh sw=2 ts=2 et
EOF

	cat &lt;&lt; EOF &gt;&gt; ${HOME}/.tmux.conf.local
set -g mouse on
set -g status-keys vi
set -g mode-keys vi

# replace C-b by C-a instead of using both prefixes
set-option -g prefix2 \` 

unbind '&quot;'
bind - splitw -v
unbind %
bind | splitw -h
# move status line to top
set -g status-position bottom

run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmux
run-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux
set -g @continuum-save-interval '1440'
set -g @continuum-restore 'on'
bind C-c run &quot; tmux save-buffer - | xclip -i -sel clipboard&quot;
bind C-v run &quot; tmux set-buffer &quot;\$(xclip -o -sel clipboard)&quot;; tmux paste-buffer&quot;
EOF
}

function set_development_environment()
{
	# set c/c++ development environment
	cat &lt;&lt; EOF &gt;&gt; ${HOME}/.zshrc
export PKG_CONFIG_PATH=${PKG_CONFIG_PATH}:/usr/local/lib/pkgconfig
mkdir -p /corefile
ulimit -c unlimited
echo &quot;1&quot; &gt; /proc/sys/kernel/core_uses_pid
echo &quot;/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern
EOF

	# TODO
	auto sudo sh -c 'echo /usr/local/lib &gt;&gt; /etc/ld.so.conf'
	auto sudo sh -c 'echo /usr/local/lib64 &gt;&gt; /etc/ld.so.conf'
}

function usage() {
    echo -e &quot;\
=================================================================================================\033[1;37m
	███████╗███╗   ██╗██╗   ██╗    ██████╗ ███████╗██████╗ ██╗      ██████╗ ██╗   ██╗
	██╔════╝████╗  ██║██║   ██║    ██╔══██╗██╔════╝██╔══██╗██║     ██╔═══██╗╚██╗ ██╔╝
	█████╗  ██╔██╗ ██║██║   ██║    ██║  ██║█████╗  ██████╔╝██║     ██║   ██║ ╚████╔╝ 
	██╔══╝  ██║╚██╗██║╚██╗ ██╔╝    ██║  ██║██╔══╝  ██╔═══╝ ██║     ██║   ██║  ╚██╔╝  
	███████╗██║ ╚████║ ╚████╔╝     ██████╔╝███████╗██║     ███████╗╚██████╔╝   ██║   
	╚══════╝╚═╝  ╚═══╝  ╚═══╝      ╚═════╝ ╚══════╝╚═╝     ╚══════╝ ╚═════╝    ╚═╝   \033[0m 
=================================================================================================&quot;
  echo &quot;Usage: $0 [options]&quot;
  echo &quot;Configure development environment for linux system&quot;
  echo &quot;Options:&quot;
  echo &quot;    -d, --distribution       linux distribution ([debian|redhat] series)&quot; 
  echo &quot;    -u, --username           set user name for git&quot; 
  echo &quot;    -e, --email              set email for git&quot; 
  echo &quot;    -p, --password           password for root&quot; 
  echo &quot;    -h, --help               Script help information&quot;
}

function main()
{
	args=`getopt -o d:u:e:p:h --long distribution:,username:,email:,password:,help -- &quot;$@&quot;`
	if [ $? != 0 ] ; then echo &quot;Terminating...&quot; &gt;&amp;2 ; exit 1 ; fi
	eval set -- &quot;$args&quot;
	
	while true; do
		case &quot;$1&quot; in
    			-d|--distribution)      distro=&quot;$2&quot;; shift 2;;
    			-u|--username)          username=&quot;$2&quot;; shift 2;;
    			-e|--email)             email=&quot;$2&quot;; shift 2;;
    			-p|--password)          password=&quot;$2&quot;; shift 2;;
    			-h|--help)              usage ; exit 0 ;;
    			--)                     shift ; break ;;
    			*)                      err &quot;invalid parameter&quot; ; exit -1 ;;
  		esac
	done
	
	if [[ -z ${distro} ]] || [[ -z ${password} ]]; then
		echo &quot;distribution and password requried&quot;
	fi
	info &quot;Starting set deployment environment for linux...&quot;
	whoami
	install_automation_tool
	install_common_tools
	configure_git
	configure_terminal
	configure_vim
	configure_fzf
	support_true_color_for_terminal
	configure_tmux
	set_development_environment
}

main $@

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Issue Template]]></title>
        <id>https://jingwoo.github.io/post/issue-template/</id>
        <link href="https://jingwoo.github.io/post/issue-template/">
        </link>
        <updated>2020-07-18T07:53:56.000Z</updated>
        <content type="html"><![CDATA[<h2 id="代码review-issue模板">代码Review issue模板</h2>
<hr>
<h3 id="code-reviewthere-is-a-logic-error-in-the-remove_name-function-of-the-rootfs_storec-file">【Code Review】There is a logic error in the remove_name function of the rootfs_store.c file</h3>
<h3 id="isulad-versionbranch">iSulad version/branch</h3>
<p>the latest version, implement_image</p>
<h3 id="code-segment">Code Segment</h3>
<pre><code class="language-c">static int remove_name(cntrootfs_t *cntr, const char *name)
{
	...
    for (i = 0; i &lt; cntr-&gt;srootfs-&gt;names_len; i++) {
        if (strcmp(cntr-&gt;srootfs-&gt;names[i], name) == 0) {
            count++;
        }
    }

    new_size = (cntr-&gt;srootfs-&gt;names_len - count) * sizeof(char *);
    tmp_names = (char **)util_common_calloc_s(new_size);
    if (tmp_names == NULL) {
        ERROR(&quot;Out of memory&quot;);
        return -1;
    }
    ...
 }
</code></pre>
<h3 id="problem-analysis">Problem Analysis</h3>
<p>When the name of the container is unique and the same as the name of the input parameter, the program will exit abnormally and there is a memory leak.</p>
<h3 id="workaround">Workaround</h3>
<p>When the name of the container is unique and the same as the name of the input parameter, the memory should be released directly, and the length is set to 0</p>
<pre><code class="language-c">static int remove_name(cntrootfs_t *cntr, const char *name)
{
	...
    for (i = 0; i &lt; cntr-&gt;srootfs-&gt;names_len; i++) {
        if (strcmp(cntr-&gt;srootfs-&gt;names[i], name) == 0) {
            count++;
        }
    }
    
	if (cntr-&gt;srootfs-&gt;names_len == count) {
        util_free_array_by_len(cntr-&gt;srootfs-&gt;names, cntr-&gt;srootfs-&gt;names_len);
        cntr-&gt;srootfs-&gt;names = NULL;
        cntr-&gt;srootfs-&gt;names_len = 0;
        return 0;
    }
    
    new_size = (cntr-&gt;srootfs-&gt;names_len - count) * sizeof(char *);
    tmp_names = (char **)util_common_calloc_s(new_size);
    if (tmp_names == NULL) {
        ERROR(&quot;Out of memory&quot;);
        return -1;
    }
    ...
 }
</code></pre>
<h3 id="代码检视rootfs_storec文件的remove_name函数存在逻辑错误">【代码检视】rootfs_store.c文件的remove_name函数存在逻辑错误</h3>
<h3 id="isulad-版本及分支">iSulad 版本及分支</h3>
<p>the latest version, implement_image</p>
<h3 id="代码片段">代码片段</h3>
<pre><code class="language-c">static int remove_name(cntrootfs_t *cntr, const char *name)
{
	...
    for (i = 0; i &lt; cntr-&gt;srootfs-&gt;names_len; i++) {
        if (strcmp(cntr-&gt;srootfs-&gt;names[i], name) == 0) {
            count++;
        }
    }

    new_size = (cntr-&gt;srootfs-&gt;names_len - count) * sizeof(char *);
    tmp_names = (char **)util_common_calloc_s(new_size);
    if (tmp_names == NULL) {
        ERROR(&quot;Out of memory&quot;);
        return -1;
    }
    ...
 }
</code></pre>
<h3 id="问题分析">问题分析</h3>
<p>当容器的names唯一且与入参name相同时，程序会异常退出且有内存泄漏。</p>
<h3 id="解决方法">解决方法</h3>
<p>当容器的names唯一且与入参name相同时，应该直接释放内存，且把长度设置成0</p>
<pre><code class="language-c">static int remove_name(cntrootfs_t *cntr, const char *name)
{
	...
    for (i = 0; i &lt; cntr-&gt;srootfs-&gt;names_len; i++) {
        if (strcmp(cntr-&gt;srootfs-&gt;names[i], name) == 0) {
            count++;
        }
    }
    
	if (cntr-&gt;srootfs-&gt;names_len == count) {
        util_free_array_by_len(cntr-&gt;srootfs-&gt;names, cntr-&gt;srootfs-&gt;names_len);
        cntr-&gt;srootfs-&gt;names = NULL;
        cntr-&gt;srootfs-&gt;names_len = 0;
        return 0;
    }
    
    new_size = (cntr-&gt;srootfs-&gt;names_len - count) * sizeof(char *);
    tmp_names = (char **)util_common_calloc_s(new_size);
    if (tmp_names == NULL) {
        ERROR(&quot;Out of memory&quot;);
        return -1;
    }
    ...
 }
</code></pre>
<h2 id="功能测试-issue模板">功能测试  issue模板</h2>
<hr>
<h3 id="function-testsegmentation-fault-from-isula-inspect">【Function Test】Segmentation fault from isula inspect</h3>
<h3 id="what-version-of-isulad-and-which-branch-are-you-using">What version of  iSulad  and which branch are you using?</h3>
<p>Client:<br>
Version:      2.0.2<br>
Git commit:   259d4126b9cfbf1ffce64ba3d65cc2de98298f76<br>
Built:        2020-06-22T15:30:09.183997400+08:00</p>
<p>Server:<br>
Version:      2.0.2<br>
Git commit:   259d4126b9cfbf1ffce64ba3d65cc2de98298f76<br>
Built:        2020-06-22T15:30:09.183997400+08:00</p>
<p>​       master &amp;&amp; stable-2.0 &amp;&amp; implement_image</p>
<h3 id="what-operating-system-linux-windows-and-version-what-compiler-are-you-using">What operating system (Linux, Windows,...) and version?  What compiler are you using ?</h3>
<p>Linux, fedora 32, gcc version 10.1.1</p>
<h3 id="what-did-you-do-and-what-did-you-see">What did you do and what did you see ?</h3>
<p>When executing command to inspect a empty object, a coredump occurs in the client program.</p>
<pre><code>➜  iSulad git:(implement_image) ✗ isula inspect &quot;&quot;
Segmentation fault (core dumpd)
</code></pre>
<h3 id="what-did-you-expect-to-see">What did you expect to see?</h3>
<p>The program does not cause coredump, and it prompts that the inspection failed. eg：</p>
<pre><code class="language-bash">➜  iSulad git:(implement_image) ✗ isula inspect  &quot;&quot;
[]
Inspect error: No such object:
</code></pre>
<h3 id="what-did-you-do-and-what-did-you-see-2">What did you do and what did you see ?</h3>
<p>When executing command to inspect a empty object, a coredump occurs in the client program.</p>
<h3 id="功能测试isula-inspect-段错误">【功能测试】isula inspect  段错误</h3>
<h3 id="isula版本信息及项目分支">iSula版本信息及项目分支</h3>
<p>Client:<br>
Version:      2.0.2<br>
Git commit:   259d4126b9cfbf1ffce64ba3d65cc2de98298f76<br>
Built:        2020-06-22T15:30:09.183997400+08:00</p>
<p>Server:<br>
Version:      2.0.2<br>
Git commit:   259d4126b9cfbf1ffce64ba3d65cc2de98298f76<br>
Built:        2020-06-22T15:30:09.183997400+08:00</p>
<p>​       master &amp;&amp; stable-2.0 &amp;&amp; implement_image</p>
<h3 id="操作系统版本及编译器版本">操作系统版本及编译器版本</h3>
<p>Linux, fedora 32, gcc version 10.1.1</p>
<h3 id="问题是如何引起的重现步骤是什么问题现象是什么">问题是如何引起的？重现步骤是什么？问题现象是什么？</h3>
<p>异常测试时，inspect空字符串会导致客户端程序coredump。</p>
<pre><code>➜  iSulad git:(implement_image) ✗ isula inspect &quot;&quot;
Segmentation fault (core dumpd)
</code></pre>
<h3 id="预期结果应该是什么">预期结果应该是什么？</h3>
<p>程序不能出现coredump，且应该有清晰的错误提示. 例如：</p>
<pre><code class="language-bash">➜  iSulad git:(implement_image) ✗ isula inspect  &quot;&quot;
[]
Inspect error: No such object:
</code></pre>
<h2 id="开发者测试-issue模板">开发者测试 issue模板</h2>
<hr>
<blockquote>
<p>c</p>
</blockquote>
<h3 id="开发者测试-升级场景加载本地已存在的v1镜像导致isulad-coredump">【开发者测试】 升级场景加载本地已存在的v1镜像导致iSulad coredump</h3>
<h3 id="用例描述">用例描述</h3>
<blockquote>
<p>测试套： StorageImagesCompatibilityUnitTest</p>
<p>用例名：test_load_v1_image</p>
</blockquote>
<pre><code class="language-c++">TEST_F(StorageImagesCompatibilityUnitTest, test_load_v1_image)
{
    ...
    opts.driver_name = strdup(&quot;overlay&quot;);
    ASSERT_EQ(image_store_init(&amp;opts), 0); --- core dumpd
    free(opts.storage_root);
	...
}
</code></pre>
<h3 id="环境">环境:</h3>
<blockquote>
<h4 id="操作系统编译器">操作系统/编译器</h4>
<blockquote>
<p>Linux, fedora 32, gcc version 10.1.1</p>
</blockquote>
<h4 id="isulad版本">iSulad版本</h4>
<blockquote>
<p>Client:<br>
Version:      2.0.2<br>
Git commit:   259d4126b9cfbf1ffce64ba3d65cc2de98298f76<br>
Built:        2020-06-22T15:30:09.183997400+08:00</p>
</blockquote>
<blockquote>
<p>Server:<br>
Version:      2.0.2<br>
Git commit:   259d4126b9cfbf1ffce64ba3d65cc2de98298f76<br>
Built:        2020-06-22T15:30:09.183997400+08:00</p>
</blockquote>
<h4 id="开发分支">开发分支</h4>
<blockquote>
<p>implement_image</p>
</blockquote>
</blockquote>
<h3 id="根因分析">根因分析</h3>
<blockquote>
<p>从layer store获取的层信息存在多个层没有parent(正常情况下只有一个层没有)</p>
</blockquote>
<h3 id="解决办法">解决办法</h3>
<blockquote>
<p>对外部模块获取的层信息进行严格校验</p>
<p>MR： https://gitee.com/openeuler/iSulad/commit/99a42f7d1c60a2140d6b3da3dd8d23196a68bca5</p>
</blockquote>
<hr>
<h3 id="dtfunction-testcode-review">[DT/Function Test/Code Review]</h3>
<h3 id="what-version-of-isulad-and-which-branch-are-you-using-2">What version of  iSulad  and which branch are you using?</h3>
<h3 id="what-operating-system-linux-windows-and-version-what-compiler-are-you-using-2">What operating system (Linux, Windows,...) and version?  What compiler are you using ?</h3>
<h3 id="what-did-you-do-and-what-did-you-see-3">What did you do and what did you see ?</h3>
<h3 id="what-did-you-expect-to-see-2">What did you expect to see?</h3>
<h3 id="开发者测试功能测试代码检视">【开发者测试/功能测试/代码检视】</h3>
<h3 id="isula版本信息及项目分支-2">iSula版本信息及项目分支</h3>
<h3 id="操作系统版本及编译器版本-2">操作系统版本及编译器版本</h3>
<h3 id="问题描述及重现步骤">问题描述及重现步骤</h3>
<h3 id="预期结果">预期结果</h3>
<h1 id="pull-request-template">Pull Request Template</h1>
<h3 id="description">Description</h3>
<h3 id="related-issue">Related Issue</h3>
<h3 id="type-of-change">Type of change</h3>
<ul>
<li>Bug Fix</li>
<li>New Feature</li>
<li>Breaking Change</li>
<li>Code Refactoring</li>
<li>Interface Change</li>
<li>Documentation Update</li>
</ul>
<h3 id="test-case">Test Case</h3>
<h3 id="validation-report">Validation Report</h3>
<ul>
<li></li>
</ul>
<h2 id="how-has-this-been-tested">How Has This Been Tested?</h2>
<p>Please describe the tests that you ran to verify your changes. Provide instructions so we can reproduce. Please also list any relevant details for your test configuration</p>
<ul>
<li>Test A</li>
<li>Test B</li>
</ul>
<p><strong>Test Configuration</strong>:</p>
<ul>
<li>
<p>Firmware version:</p>
</li>
<li>
<p>Hardware:</p>
</li>
<li>
<p>Toolchain:</p>
</li>
<li>
<p>SDK:</p>
</li>
<li></li>
</ul>
<h3 id="描述">描述</h3>
<h3 id="关联issue">关联issue</h3>
<h3 id="修改类型">修改类型</h3>
<ul>
<li>问题修复</li>
<li>新特性开发</li>
<li>代码重构</li>
<li>接口变更</li>
<li>文档更新</li>
</ul>
<h3 id="测试用例">测试用例</h3>
<h3 id="验证报告">验证报告</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[ Introduction to SELinux]]></title>
        <id>https://jingwoo.github.io/post/introduction-to-selinux/</id>
        <link href="https://jingwoo.github.io/post/introduction-to-selinux/">
        </link>
        <updated>2020-07-17T07:55:31.000Z</updated>
        <content type="html"><![CDATA[<h2 id="selinux-overview">SELinux Overview</h2>
<figure data-type="image" tabindex="1"><img src="https://jingwoo.github.io/post-images/1594972737178.jpg" alt="" loading="lazy"></figure>
<p><em>Security-Enhanced Linux</em> (SELinux) is a security architecture integrated into the 2.6.<em><code>x</code></em> kernel using the <em>Linux Security Modules</em> (LSM). It is a project of the United States National Security Agency (NSA) and the SELinux community.</p>
<p>Security Enhanced Linux (SELinux) provides an additional layer of system security. SELinux fundamentally answers the question: &quot;May <subject> do <action> to <object>&quot;, for example: &quot;May a web server access files in users' home directories?&quot;. All processes and files are labeled. SELinux policy rules define how processes interact with files, as well as how processes interact with each other.</p>
<h2 id="selinux-architectrue">SELinux  Architectrue</h2>
<p>SELinux is a Linux Security Module (LSM) that is built into the Linux kernel. The SELinux subsystem in the kernel is driven by a security policy which is controlled by the administrator and loaded at boot. All security-relevant, kernel-level access operations on the system are intercepted by SELinux and  examined in the context of the loaded security policy. If the loaded policy allows the operation, it<br>
continues. Otherwise, the operation is blocked and the process receives an error. SELinux decisions, such as allowing or disallowing access, are cached. This cache is known as the Access Vector Cache (AVC). When using these cached decisions, SELinux policy rules need to be checked less, which increases performance. Remember that SELinux policy rules have no effect if DAC rules deny access first.</p>
<h2 id="selinux-package">SELinux Package</h2>
<p><em>policycoreutils</em>: provides utilities, such as <code>semanage</code>, <code>restorecon</code>, <code>audit2allow</code>, <code>semodule</code>, <code>load_policy</code>, and <code>setsebool</code>, for operating and managing SELinux.</p>
<p><em>selinux-policy</em>: provides the SELinux Reference Policy. Provides a basic directory structure, the selinux-policy.conf file, and RPM<br>
macros</p>
<p><em>selinux-policy-targeted</em>: provides the SELinux targeted policy</p>
<p><em>selinux-policy-targeted</em>: provides the SELinux targeted policy.</p>
<p><em>libselinux</em>: provides an API for SELinux applications.</p>
<p><em>libselinux-utils</em>: provides the avcstat, getenforce, getsebool, matchpathcon, selinuxconlist, selinuxdefcon, selinuxenabled, and setenforce utilities.</p>
<p><em>libselinux-python</em>: provides Python bindings for developing SELinux applications.</p>
<p><em>selinux-policy-devel</em>: provides utilities for creating a custom SELinux policy and policy modules.</p>
<p><em>selinux-policy-doc</em>: provides manual pages that describe how to configure SELinux altogether with various services.</p>
<p><em>selinux-policy-mls</em>: provides the MLS (Multi-Level Security) SELinux policy. setroubleshoot-server translates denial messages, produced when access is denied by SELinux, into detailed descriptions that can be viewed with the sealert utility, also provided in this<br>
package.</p>
<p><em>setools-console</em>: provides the Tresys Technology SETools distribution , a number of utilities and libraries for analyzing and querying policy, audit log monitoring and reporting, and file context management. The setools package is a meta-package for SETools. The setools-gui package provides the apol and seaudit utilities. The setools-console package provides the sechecker, sediff, seinfo, sesearch, and findcon command-line utilities. See the Tresys Technology SETools page for information about these utilities. Note that setools and setools-gui packages are available only when the Red Hat Network Optional channel is enabled. For further<br>
information, see Scope of Coverage Details. mcstrans translates levels, such as s0-s0:c0.c1023, to a form that is easier to read, such as SystemLow-SystemHigh.</p>
<p><em>setools</em>, <em>setools-gui</em>, and <em>setools-console</em>: these packages provide the <a href="http://oss.tresys.com/projects/setools">Tresys Technology SETools distribution</a>, a number of tools and libraries for analyzing and querying policy, audit log monitoring and reporting, and file context management.</p>
<p><em>libselinux-utils</em>: provides the <code>avcstat</code>, <code>getenforce</code>, <code>getsebool</code>, <code>matchpathcon</code>, <code>selinuxconlist</code>, <code>selinuxdefcon</code>, <code>selinuxenabled</code>, <code>setenforce</code>, <code>togglesebool</code> tools.</p>
<p><em>mcstrans</em>: translates levels, such as <code>s0-s0:c0.c1023</code>, to an easier to read form, such as <code>SystemLow-SystemHigh</code>. This package is not installed by default.</p>
<p><em>policycoreutils-python</em>: provides utilities such as semanage, audit2allow, audit2why, and chcat, for operating and managing SELinux.</p>
<p><em>policycoreutils-gui</em>: provides system-config-selinux, a graphical utility for managing SELinux.</p>
<h2 id="selinux-states-and-modes">SELinux States And Modes</h2>
<p>SELinux can run in one of three modes: disabled, permissive, or enforcing.</p>
<p>Disabled mode is strongly discouraged; not only does the system avoid enforcing the SELinux policy, it also avoids labeling any persistent objects such as files, making it difficult to enable SELinux in the future.</p>
<p>In permissive mode, the system acts as if SELinux is enforcing the loaded security policy, including labeling objects and emitting access denial entries in the logs, but it does not actually deny any operations. While not recommended for production systems, permissive mode can be helpful for SELinux policy development.</p>
<p>Enforcing mode is the default, and recommended, mode of operation; in enforcing mode SELinux operates normally, enforcing the loaded security policy on the entire system.</p>
<pre><code class="language-bash">$ cat /etc/selinux/config
# This file controls the state of SELinux on the system.
# SELINUX= can take one of these three values:
# enforcing - SELinux security policy is enforced.
# permissive - SELinux prints warnings instead of enforcing.
# disabled - No SELinux policy is loaded.
SELINUX=enforcing
# SELINUXTYPE= can take one of these two values:
# default - equivalent to the old strict and targeted policies
# mls     - Multi-Level Security (for military and educational use)
# src     - Custom policy built from source
SELINUXTYPE=default

# SETLOCALDEFS= Check local definition changes
SETLOCALDEFS=0
</code></pre>
<p>Use the <code>setenforce</code> utility to change between enforcing and permissive mode.</p>
<pre><code class="language-bash"># Use Enforcing or 1 to put SELinux in enforcing mode.
# Use Permissive or 0 to put SELinux in permissive mode.
$ setenforce [Enforcing|Permissive|1|0]
</code></pre>
<p>Use the <code>getenforce</code> or <code>sestatus</code> commands to check in which mode SELinux is running. The <code>getenforce</code> command returns <code>Enforcing</code>, <code>Permissive</code>, or <code>Disabled</code>.</p>
<pre><code class="language-bash">$ getenforce
</code></pre>
<pre><code class="language-bash">$ sestatus
SELinux status:                 enabled
SELinuxfs mount:                /sys/fs/selinux
SELinux root directory:         /etc/selinux
Loaded policy name:             targeted
Current mode:                   enforcing
Mode from config file:          enforcing
Policy MLS status:              enabled
Policy deny_unknown status:     allowed
Memory protection checking:     actual (secure)
Max kernel policy version:      32
</code></pre>
<p>Set individual domains to permissive mode while the system runs in enforcing mode.</p>
<pre><code class="language-bash">semanage permissive -a container_t
</code></pre>
<h2 id="enabledisable-selinux-on-linux">Enable/Disable SELinux On Linux</h2>
<h3 id="ubuntu">Ubuntu</h3>
<pre><code class="language-bash">## Enable SELinux
# Install SELinux package
$ sudo apt install policycoreutils selinux-utils selinux-basics
# Activate SELinux
$ sudo selinux-activate
# Set SELinux to enforcing mode
$ sudo selinux-config-enforcing
# Reboot system
$ reboot
# Check SELinux states
$ sestatus

## Disable SELinux
# set states
sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled&quot; /etc/selinux/config
# reboot system
$ reboot
</code></pre>
<h3 id="fedora">Fedora</h3>
<pre><code class="language-bash">## Enable SELinux
# Install SELinux package
$ sudo dnf install policycoreutils selinux-policy setools setools-console libselinux-utils setroubleshoot selinux-policy-targeted selinux-policy libselinux libselinux-python policycoreutils-python
# set states
$ vim /etc/selinux/config
	# This file controls the state of SELinux on the system.
    # SELINUX= can take one of these three values:
    #       enforcing - SELinux security policy is enforced.
    #       permissive - SELinux prints warnings instead of enforcing.
    #       disabled - No SELinux policy is loaded.
    SELINUX=pass:quotes[*enforcing*]
    # SELINUXTYPE= can take one of these two values:
    #       targeted - Targeted processes are protected,
    #       mls - Multi Level Security protection.
    SELINUXTYPE=targeted
# reboot system
$ reboot

## Disable SELinux
# set states
sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled&quot; /etc/selinux/config
# reboot system
$ reboot
</code></pre>
<h2 id="selinux-context">SELinux Context</h2>
<p>Processes and files are labeled with an SELinux context that contains additional information, such as an SELinux user, role, type, and, optionally, a level. When running SELinux, all of this information is used to make access control decisions.  SELinux provides a combination of RoleBased Access Control (RBAC), Type Enforcement (TE), and, optionally, Multi-Level Security (MLS).</p>
<p>SELinux contexts follow the SELinux user:role:type:level syntax.</p>
<pre><code class="language-bash">$ ls -Z /etc/adjtime
-rw-r--r--. root root system_u:object_r:adjtime_t:s0   /etc/adjtime
$ stat -c &quot;%C&quot; /etc/adjtime
system_u:object_r:adjtime_t:s0
</code></pre>
<h3 id="selinux-user">SELinux user</h3>
<p>The SELinux user identity is an identity known to the policy that is authorized for a specific set of<br>
roles, and for a specific MLS/MCS range.</p>
<pre><code class="language-bash">$ semanage login -l
Login Name           SELinux User         MLS/MCS Range        Service
__default__          unconfined_u         s0-s0:c0.c1023       *
root                 unconfined_u         s0-s0:c0.c1023       *
$ id -Z
unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023
$ seinfo -u
Users: 6
   root
   staff_u
   sysadm_u
   system_u
   unconfined_u
   user_u
</code></pre>
<h3 id="selinux-role">SELinux Role</h3>
<p>Part of SELinux is the Role-Based Access Control (RBAC) security model. The role is an attribute of RBAC. SELinux users are authorized for roles, and roles are authorized for domains. The role serves as an intermediary between domains and SELinux users. The roles that can be entered determine which domains can be entered; ultimately, this controls which object types can be accessed. This helps reduce vulnerability to privilege escalation attacks.</p>
<p>To list all available roles, enter the following command:</p>
<pre><code class="language-bash">$ seinfo -r
</code></pre>
<h3 id="selinux-type">SELinux Type</h3>
<p>The type is an attribute of Type Enforcement. The type defines a domain for processes, and a type for files. SELinux policy rules define how types can access each other, whether it be a domain accessing a type, or a domain accessing another domain. Access is only allowed if a specific SELinux policy rule exists that allows it.</p>
<h3 id="selinux-level">SELinux Level</h3>
<p>The level is an attribute of MLS and MCS. An MLS range is a pair of levels, written as lowlevelhighlevel if the levels differ, or lowlevel if the levels are identical ( s0-s0 is the same as s0). Each level is a sensitivity-category pair, with categories being optional. If there are categories, the level is written as sensitivity:category-set. If there are no categories, it is written as sensitivity. If the category set is a contiguous series, it can be abbreviated. For example, c0.c3 is the same as c0,c1,c2,c3. The /etc/selinux/targeted/setrans.conf file maps levels (s0:c0) to human-readable form (that is CompanyConfidential). In Red Hat Enterprise Linux, targeted policy enforces MCS, and in MCS, there is just one sensitivity, s0. MCS in Red Hat Enterprise Linux supports 1024 different categories: c0 through to c1023. s0-s0:c0.c1023 is sensitivity s0 and authorized for all categories.</p>
<h2 id="selinux-relabel-file">SELinux  Relabel File</h2>
<p>The <code>chcon</code> command changes the SELinux context for files  (Temporary Changes )</p>
<pre><code class="language-bash">chcon -R -t container_ro_file_t /var/lib/isulad/storage/overlay2
</code></pre>
<p><code>restorecon</code> command reads the files in the <code>/etc/selinux/targeted/contexts/files/</code> directory, to see which SELinux context files should have.</p>
<pre><code class="language-bash">$ restorecon -R -v /var/lib/isulad/storage/overlay2
restorecon reset /var/lib/isulad/storage/overlay2 context unconfined_u:object_r:container_ro_file_t:s0-
&gt;system_u:object_r:var_lib_t:s0
</code></pre>
<p>The <code>semanage fcontext</code> command is used to change the SELinux context of files.    (Persistent Changes )</p>
<pre><code class="language-bash">$ sudo semanage fcontext -a options file-name|directory-name
</code></pre>
<p>Use the ·restorecon· utility to apply the context changes:</p>
<pre><code class="language-bash">$ sudo restorecon -v file-name|directory-name
</code></pre>
<p>Deleting an added Context</p>
<pre><code class="language-bash">$ sudo semanage fcontext -d file-name|directory-name
</code></pre>
<h2 id="checking-the-default-selinux-context">Checking the Default SELinux Context</h2>
<pre><code class="language-bash">$ chcon -R system_u:object_r:container_ro_file_t:s0 /var/lib/isulad/storage/overlay
$ matchpathcon -V /var/lib/isulad/storage/overlay
/var/lib/isulad/storage/overlay has context system_u:object_r:container_ro_file_t:s0, should be system_u:object_r:var_lib_t:s0
</code></pre>
<h2 id="selinux-context-process">SELinux Context Process</h2>
<p>Use the ps -eZ command to view the SELinux context for processes.</p>
<pre><code class="language-bash">$ ps -eZ | grep passwd
unconfined_u:unconfined_r:passwd_t:s0-s0:c0.c1023 13212 pts/1 00:00:00 passwd
</code></pre>
<h2 id="selinux-boolean">SELinux Boolean</h2>
<p>Booleans allow parts of SELinux policy to be changed at runtime, without any knowledge of SELinux<br>
policy writing. This allows changes, such as allowing services access to NFS volumes, without reloading<br>
or recompiling SELinux policy.</p>
<pre><code class="language-bash">$ semanage boolean -l
SELinux boolean                State  Default Description
allow_cvs_read_shadow          (off  ,  off)  Determine whether cvs can read shadow password files.
...
$ getsebool -a
allow_cvs_read_shadow-&gt;off
...
$ getsebool allow_cvs_read_shadow
allow_cvs_read_shadow-&gt;off
$ setsebool allow_cvs_read_shadow [on/off]
# setsebool -P boolean-name on, To make changes persistent across reboots

</code></pre>
<h2 id="selinux-information-gathering-tools">SELinux Information Gathering Tools</h2>
<pre><code class="language-bash">$ man seinfo
$ man sesearch
$ sesearch -A -s var_lib_t
allow file_type fs_t:filesystem associate;
allow file_type hugetlbfs_t:filesystem associate;
allow file_type noxattrfs:filesystem associate;
allow file_type ramfs_t:filesystem associate;
allow file_type tmp_t:filesystem associate;
allow file_type tmpfs_t:filesystem associate;
allow var_lib_t var_lib_t:filesystem associate;
</code></pre>
<p>To see which objects are labeled as type</p>
<pre><code class="language-bash">$ semanage fcontext -l | grep httpd_log_t
/var/log/httpd(/.)?                               all files          system_u:object_r:httpd_log_t:s0  
/var/log/nginx(/.)?                               all files          system_u:object_r:httpd_log_t:s0 
...
</code></pre>
<h2 id="prioritizing-and-disabling-selinux-policy-modules">Prioritizing And Disabling SELinux Policy Modules</h2>
<p>Install the module with the <code>semodule -i</code> command and set the priority of the module to 400</p>
<pre><code class="language-bash">$ semodule -X 400 -i sandbox.pp
$ semodule --list-modules=full | grep sandbox
400 sandbox pp
100 sandbox pp
</code></pre>
<p>Disabling a System Policy Module</p>
<pre><code class="language-bash">semodule -d sandbox
</code></pre>
<h2 id="writing-selinux-policy">Writing SELinux Policy</h2>
<p>The Guide to Writing SELinux Policy</p>
<blockquote>
<p>https://www.linuxtopia.org/online_books/writing_SELinux_policy_guide</p>
</blockquote>
<p>SELinux Policy for Container Runtimes</p>
<blockquote>
<p>https://github.com/containers/container-selinux</p>
</blockquote>
<h2 id="understanding-denials">Understanding Denials</h2>
<p>When SELinux prevents any software from accessing a particular resource, it generates a message and logs it in <code>/var/log/audit/audit.log</code> or <code>/var/log/messages</code> if <strong>audit</strong> service is disabled.</p>
<table>
<thead>
<tr>
<th style="text-align:left">Daemon</th>
<th style="text-align:left">Log Location</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">auditd on</td>
<td style="text-align:left"><code>/var/log/audit/audit.log</code></td>
</tr>
<tr>
<td style="text-align:left">auditd off; rsyslogd on</td>
<td style="text-align:left"><code>/var/log/messages</code></td>
</tr>
<tr>
<td style="text-align:left">setroubleshootd, rsyslogd, and auditd on</td>
<td style="text-align:left"><code>/var/log/audit/audit.log</code>. Easier-to-read denial messages also sent to <code>/var/log/messages</code></td>
</tr>
</tbody>
</table>
<p>if DAC rules (standard Linux permissions) allow access, check <code>/var/log/messages</code> and <code>/var/log/audit/audit.log</code> for <code>&quot;SELinux is preventing&quot;</code> and <code>&quot;denied&quot;</code> errors respectively. This can be done by running the following commands as the root user:</p>
<pre><code class="language-bash">$ ausearch -m AVC,USER_AVC,SELINUX_ERR -ts today
$ sudo grep &quot;SELinux is preventing&quot; /var/log/messages
$ sudo grep &quot;denied&quot; /var/log/audit/audit.log
$ aureport -a
</code></pre>
<table>
<thead>
<tr>
<th>Searching For Command</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>all denials</td>
<td><code>ausearch -m avc,user_avc,selinux_err,user_selinux_err</code></td>
</tr>
<tr>
<td>denials for that today</td>
<td><code>ausearch -m avc -ts today</code></td>
</tr>
<tr>
<td>denials from the last 10 minutes</td>
<td><code>ausearch -m avc -ts recent</code></td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Windows Terminal Configuration]]></title>
        <id>https://jingwoo.github.io/post/windows-terminal-configuration/</id>
        <link href="https://jingwoo.github.io/post/windows-terminal-configuration/">
        </link>
        <updated>2020-07-15T09:52:28.000Z</updated>
        <content type="html"><![CDATA[<h2 id="useful-keyboard-shortcuts-in-windows-terminal">Useful Keyboard Shortcuts in windows terminal</h2>
<table>
<thead>
<tr>
<th style="text-align:left">Command</th>
<th>Shortcuts</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Open a new tab</td>
<td>ctrl+shift+t</td>
</tr>
<tr>
<td style="text-align:left">Open a new pane</td>
<td>alt+shift+d</td>
</tr>
<tr>
<td style="text-align:left">Duplicate tab</td>
<td>ctrl+shift+d</td>
</tr>
<tr>
<td style="text-align:left">Open default settings files</td>
<td>ctrl+alt+,</td>
</tr>
<tr>
<td style="text-align:left">Toggle full screen</td>
<td>f11</td>
</tr>
<tr>
<td style="text-align:left">Open next tab</td>
<td>ctrl+tab</td>
</tr>
<tr>
<td style="text-align:left">Open previous tab</td>
<td>ctrl+shift+tab</td>
</tr>
<tr>
<td style="text-align:left">Open a specific tab</td>
<td>ctrl+alt+1</td>
</tr>
<tr>
<td style="text-align:left">Close pane</td>
<td>ctrl+shift+w</td>
</tr>
<tr>
<td style="text-align:left">Move pane focus</td>
<td>alt+&quot;left&quot;<code>,</code>&quot;right&quot;<code>,</code>&quot;up&quot;<code>,</code>&quot;down&quot;</td>
</tr>
<tr>
<td style="text-align:left">Resize a pane</td>
<td>alt+shift+&quot;left&quot;<code>,</code>&quot;right&quot;<code>,</code>&quot;up&quot;<code>,</code>&quot;down&quot;</td>
</tr>
</tbody>
</table>
<h2 id="set-up-powerline-in-windows-terminal">Set up Powerline in Windows Terminal</h2>
<h3 id="set-up-powerline-in-powershell">Set up Powerline in PowerShell</h3>
<pre><code class="language-bash"># Run PowerShell as administrator
Install-Module posh-git -Scope CurrentUser
Install-Module oh-my-posh -Scope CurrentUser
Install-Module -Name PSReadLine -Scope CurrentUser -Force -SkipPublisherCheck
</code></pre>
<h3 id="customize-your-powershell-prompt">Customize your PowerShell prompt</h3>
<pre><code class="language-bash">$ notepad $PROFILE
	Import-Module posh-git
	Import-Module oh-my-posh
	Set-Theme Paradox
</code></pre>
<h2 id="customize-windows-terminal-profile-settings">Customize Windows Terminal Profile Settings</h2>
<pre><code class="language-json">// This file was initially generated by Windows Terminal 1.0.1401.0
// It should still be usable in newer versions, but newer versions might have additional
// settings, help text, or changes that you will not see unless you clear this file
// and let us generate a new one for you.

// To view the default settings, hold &quot;alt&quot; while clicking on the &quot;Settings&quot; button.
// For documentation on these settings, see: https://aka.ms/terminal-documentation
{
    &quot;$schema&quot;: &quot;https://aka.ms/terminal-profiles-schema&quot;,

    &quot;defaultProfile&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,

    // You can add more global application settings here.
    // To learn more about global settings, visit https://aka.ms/terminal-global-settings

    // If enabled, selections are automatically copied to your clipboard.
    &quot;copyOnSelect&quot;: true,

    // If enabled, formatted data is also copied to your clipboard
    &quot;copyFormatting&quot;: false,

    &quot;theme&quot;: &quot;dark&quot;,

    &quot;alwaysShowTabs&quot;: false,

    &quot;showTabsInTitlebar&quot;: true,

    &quot;confirmCloseAllTabs&quot;: true,

    &quot;wordDelimiters&quot;: &quot; ./\\()\&quot;'-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]{}~?│&quot;,

    &quot;snapToGridOnResize&quot;: true,

    // A profile specifies a command to execute paired with information about how it should look and feel.
    // Each one of them will appear in the 'New Tab' dropdown,
    //   and can be invoked from the commandline with `wt.exe -p xxx`
    // To learn more about profiles, visit https://aka.ms/terminal-profile-settings
    &quot;profiles&quot;:
    {
        &quot;defaults&quot;:
        {
            // Put settings here that you want to apply to all profiles.
            &quot;padding&quot;: &quot;0, 0, 0, 0&quot;
        },
        &quot;list&quot;:
        [
            {
                // Make changes here to the powershell.exe profile.
                &quot;guid&quot;: &quot;{61c54bbd-c2c6-5271-96e7-009a87ff44bf}&quot;,
                &quot;name&quot;: &quot;Windows PowerShell&quot;,
                &quot;commandline&quot;: &quot;powershell.exe&quot;,
                &quot;hidden&quot;: false,
                &quot;acrylicOpacity&quot;: 0.7,
                &quot;colorScheme&quot; : &quot;Frost&quot;,
                &quot;cursorColor&quot; : &quot;#000000&quot;,
                &quot;fontFace&quot;: &quot;Cascadia Code PL&quot;,
                &quot;useAcrylic&quot;: true
            },
            {
                &quot;name&quot;: &quot;Ubuntu-20.04&quot;,
                &quot;tabTitle&quot;: &quot;Ubuntu 💻&quot;,
                &quot;source&quot;: &quot;Windows.Terminal.Wsl&quot;,
                &quot;colorScheme&quot;: &quot;Solarized Dark&quot;,
                &quot;startingDirectory&quot;: &quot;//wsl$/Ubuntu-20.04/root&quot;,
                &quot;guid&quot;: &quot;{07b52e3e-de2c-5db4-bd2d-ba144ed6c273}&quot;,
                &quot;fontFace&quot;: &quot;Consolas&quot;,
                &quot;padding&quot;: &quot;0, 0, 0, 0&quot;,
                &quot;antialiasingMode&quot;: &quot;grayscale&quot;,
                &quot;cursorShape&quot;: &quot;bar&quot;,
                &quot;scrollbarState&quot;: &quot;hidden&quot;,
                &quot;historySize&quot;: 9001,
                &quot;closeOnExit&quot;: &quot;graceful&quot;,
                &quot;hidden&quot;: false,
                // &quot;experimental.retroTerminalEffect&quot;: true,
                &quot;acrylicOpacity&quot;: 0.8,
                &quot;useAcrylic&quot;: true
            },
            {
                &quot;acrylicOpacity&quot; : 0.5,
                &quot;closeOnExit&quot; : true,
                &quot;colorScheme&quot; : &quot;One Half Dark&quot;,
                &quot;commandline&quot; : &quot;ssh root@ip&quot;,
                &quot;cursorColor&quot; : &quot;#FFFFFF&quot;,
                &quot;cursorShape&quot; : &quot;bar&quot;,
                &quot;fontFace&quot; : &quot;Consolas&quot;,
                &quot;fontSize&quot; : 14,
                &quot;guid&quot; : &quot;{592D0432-1020-4DF6-83D4-928A7BE1D31A}&quot;,
                &quot;historySize&quot; : 9001,
                &quot;icon&quot; : &quot;ms-appx:///ProfileIcons/{9acb9455-ca41-5af7-950f-6bca1bc9722f}.png&quot;,
                &quot;name&quot; : &quot;xxxx&quot;,
                &quot;snapOnInput&quot; : true,
                &quot;startingDirectory&quot; : &quot;&quot;,
                &quot;useAcrylic&quot; : false
            }
        ]
    },

    // Add custom color schemes to this array.
    // To learn more about color schemes, visit https://aka.ms/terminal-color-schemes
    &quot;schemes&quot;: [
        {
            &quot;name&quot; : &quot;Frost&quot;,
            &quot;background&quot; : &quot;#FFFFFF&quot;,
            &quot;black&quot; : &quot;#3C5712&quot;,
            &quot;blue&quot; : &quot;#17b2ff&quot;,
            &quot;brightBlack&quot; : &quot;#749B36&quot;,
            &quot;brightBlue&quot; : &quot;#27B2F6&quot;,
            &quot;brightCyan&quot; : &quot;#13A8C0&quot;,
            &quot;brightGreen&quot; : &quot;#89AF50&quot;,
            &quot;brightPurple&quot; : &quot;#F2A20A&quot;,
            &quot;brightRed&quot; : &quot;#F49B36&quot;,
            &quot;brightWhite&quot; : &quot;#741274&quot;,
            &quot;brightYellow&quot; : &quot;#991070&quot;,
            &quot;cyan&quot; : &quot;#3C96A6&quot;,
            &quot;foreground&quot; : &quot;#000000&quot;,
            &quot;green&quot; : &quot;#6AAE08&quot;,
            &quot;purple&quot; : &quot;#991070&quot;,
            &quot;red&quot; : &quot;#8D0C0C&quot;,
            &quot;white&quot; : &quot;#6E386E&quot;,
            &quot;yellow&quot; : &quot;#991070&quot;
        }
    ],

    // Add custom keybindings to this array.
    // To unbind a key combination from your defaults.json, set the command to &quot;unbound&quot;.
    // To learn more about keybindings, visit https://aka.ms/terminal-keybindings
    &quot;keybindings&quot;:
    [
        // Copy and paste are bound to Ctrl+Shift+C and Ctrl+Shift+V in your defaults.json.
        // These two lines additionally bind them to Ctrl+C and Ctrl+V.
        // To learn more about selection, visit https://aka.ms/terminal-selection
        { &quot;command&quot;: {&quot;action&quot;: &quot;copy&quot;, &quot;singleLine&quot;: false }, &quot;keys&quot;: &quot;ctrl+c&quot; },
        { &quot;command&quot;: &quot;paste&quot;, &quot;keys&quot;: &quot;ctrl+v&quot; },

        // Press Ctrl+Shift+F to open the search box
        { &quot;command&quot;: &quot;find&quot;, &quot;keys&quot;: &quot;ctrl+shift+f&quot; },

        // Press Alt+Shift+D to open a new pane.
        // - &quot;split&quot;: &quot;auto&quot; makes this pane open in the direction that provides the most surface area.
        // - &quot;splitMode&quot;: &quot;duplicate&quot; makes the new pane use the focused pane's profile.
        // To learn more about panes, visit https://aka.ms/terminal-panes
        { &quot;command&quot;: { &quot;action&quot;: &quot;splitPane&quot;, &quot;split&quot;: &quot;auto&quot;, &quot;splitMode&quot;: &quot;duplicate&quot; }, &quot;keys&quot;: &quot;alt+shift+d&quot; }
    ]
}

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux Development Environment Configuration for iSulad]]></title>
        <id>https://jingwoo.github.io/post/linux-development-environment-configuration-for-isulad/</id>
        <link href="https://jingwoo.github.io/post/linux-development-environment-configuration-for-isulad/">
        </link>
        <updated>2020-07-12T07:12:54.000Z</updated>
        <content type="html"><![CDATA[<h2 id="virtual-machine-installation">Virtual machine installation</h2>
<pre><code class="language-bash">qemu-img create -f raw -o size=120G Fedora_Server.img
virsh dumpxml {guest-id, guestname or uuid} &gt; Fedora_Server.xml
virsh define Fedora_Server.xml
virsh start Fedora_Server
virsh vncdisplay Fedora_Server
</code></pre>
<h2 id="network-configuration">Network Configuration</h2>
<pre><code class="language-bash">vim /etc/sysconfig/network-scripts/ifcfg-ens3
systemctl enable NetworkManager
systemctl start NetworkManager
proxy
</code></pre>
<h2 id="awesome-tools-installation">Awesome Tools Installation</h2>
<pre><code class="language-bash">dnf upgrade -y 
dnf autoremove -y
dnf install -y vim htop the_silver_searcher fd-find bat exa ccze git tig 
dnf install -y fzf glances tmux ShellCheck ranger aria2 axel cloc task jq zsh npm
dnf install -y cmatrix screenfetch mariadb-server mariadb mycli
</code></pre>
<pre><code class="language-bash">git config --global user.name username
git config --global user.email email@xxx.com
git config --global http.sslVerify false

dnf install npm
npm install -g diff-so-fancy
git config --global core.pager &quot;diff-so-fancy | less --tabs=4 -RFX&quot;
git config --global color.ui true
git config --global color.diff-highlight.oldNormal    &quot;red bold&quot;
git config --global color.diff-highlight.oldHighlight &quot;red bold 52&quot;
git config --global color.diff-highlight.newNormal    &quot;green bold&quot;
git config --global color.diff-highlight.newHighlight &quot;green bold 22&quot;

git config --global color.diff.meta       &quot;11&quot;
git config --global color.diff.frag       &quot;magenta bold&quot;
git config --global color.diff.commit     &quot;yellow bold&quot;
git config --global color.diff.old        &quot;red bold&quot;
git config --global color.diff.new        &quot;green bold&quot;
git config --global color.diff.whitespace &quot;red reverse&quot;
git config --bool --global diff-so-fancy.markEmptyLines false
git config --bool --global diff-so-fancy.changeHunkIndicators false
git config --bool --global diff-so-fancy.stripLeadingSymbols false
git config --bool --global diff-so-fancy.useUnicodeRuler false
git config --global diff-so-fancy.rulerWidth 47    # git log's commit header width
</code></pre>
<pre><code class="language-bash">sh -c &quot;$(curl -kfsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
cat ~/.zshrc
plugins=(git zsh-autosuggestions extract zsh-syntax-highlighting history-substring-search history zsh-256color vi-mode z wd taskwarrior)
# git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
# git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting
# git clone https://github.com/zsh-users/zsh-history-substring-search ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-history-substring-search
# cd $ZSH_CUSTOM/plugins &amp;&amp; git clone https://github.com/chrissicool/zsh-256color

vim plugins/history-substring-search/history-substring-search.plugin.zsh
bindkey '^[[A' history-substring-search-up
bindkey '^[[B' history-substring-search-down

vim plugins/zsh-autosuggestions/zsh-autosuggestions.zsh
typeset -g ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE='fg=3'

git clone https://github.com/junegunn/fzf.git
./install
vim ~/.zshrc
[ -f ~/.fzf.zsh ] &amp;&amp; source ~/.fzf.zsh
export FZF_DEFAULT_COMMAND='fd --hidden --follow -E &quot;.git&quot; -E &quot;node_modules&quot; . /etc /home'
export FZF_DEFAULT_OPTS='--height 90% --layout=reverse --bind=alt-j:down,alt-k:up,alt-i:toggle+down --border --preview &quot;(bat --style=numbers --color=always {}) 2&gt; /dev/null | head -500&quot; --preview-window=down'

# use fzf in bash and zsh
# Use ~~ as the trigger sequence instead of the default **
# export FZF_COMPLETION_TRIGGER=' f'
#

# Options to fzf command
#export FZF_COMPLETION_OPTS=''
#

# Use fd (https://github.com/sharkdp/fd) instead of the default find
# command for listing path candidates.
# - The first argument to the function ($1) is the base path to start traversal
# - See the source code (completion.{bash,zsh}) for the details.
#
_fzf_compgen_path() {
  fd --hidden --follow -E &quot;.git&quot; -E &quot;node_modules&quot; . /etc /home
}

# Use fd to generate the list for directory completion
_fzf_compgen_dir() {
  fd --type d --hidden --follow -E &quot;.git&quot; -E &quot;node_modules&quot; . /etc /home
}

</code></pre>
<pre><code class="language-bash">dnf install -y ctags cscope global
dnf install -y neovim
pip2 install --no-cache-dir --upgrade --force-reinstall neovim
pip3 install --no-cache-dir --upgrade --force-reinstall neovim


vim ~/.zshrc
alias vi='nvim'
alias vim='nvim'

curl -ksLf https://spacevim.org/install.sh | bash
cat ~/.SpaceVim.d/init.toml
[options]
    # set spacevim theme. by default colorscheme layer is not loaded,
    # if you want to use more colorscheme, please load the colorscheme
    # layer
    # colorscheme = &quot;gruvbox&quot;
    colorscheme = &quot;NeoSolarized&quot;
    colorscheme_bg = &quot;dark&quot;
    # Disable guicolors in basic mode, many terminal do not support 24bit
    # true colors
    enable_guicolors = true
    # Disable statusline separator, if you want to use other value, please
    # install nerd fonts
    statusline_separator = &quot;arrow&quot;
    statusline_inactive_separator = &quot;bar&quot;
    buffer_index_type = 4
    windows_index_type = 3
    enable_statusline_mode = true
     # left sections of statusline
    statusline_left_sections = [
       'winnr',
       'major mode',
       'filename',
       'fileformat',
       'minor mode lighters',
       'version control info',
       'search status'
    ]
    # right sections of statusline
    statusline_right_sections = [
       'cursorpos',
       'percentage',
       'input method',
       'date',
       'time'
    ]

    enable_tabline_filetype_icon = true
    enable_statusline_display_mode = true
    statusline_unicode_symbols = true
    realtime_leader_guide = 1
    enable_statusline_tag = true
    # Enable vim compatible mode, avoid changing origin vim key bindings
    vimcompatible = true
    automatic_update = true
    enable_neomake = false
    # enable_ale = true
    filemanager = &quot;defx&quot;
    # enable_ycm = 1
    # autocomplete_method = &quot;coc&quot;

# Enable autocomplete layer
# [[layers]]
# name = 'autocomplete'
# autocomplete_method = &quot;ycm&quot;
# auto-completion-return-key-behavior = &quot;complete&quot;
# auto-completion-tab-key-behavior = &quot;smart&quot;
# enable = false

[[custom_plugins]]
  name = 'neoclide/coc.nvim'
  merge = 0
  build =  'yarn install --frozen-lockfile'

# [[layers]]
  # name = 'lsp'
  # filetypes = [
    # 'c',
    # 'cpp'
  # ]

# [layers.override_cmd]
  # c = ['ccls', '--log-file=/tmp/ccls.log']
  # cpp = ['ccls', '--log-file=/tmp/ccls.log']

[[layers]]
name = 'shell'
default_position = 'right'

# [[layers]]
# name = &quot;cscope&quot;

[[layers]]
name = &quot;VersionControl&quot;
enable-gtm-status = true

[[layers]]
name = &quot;checkers&quot;
show_cursor_error = false

[[layers]]
 name = &quot;colorscheme&quot;

# [[layers]]
# name = &quot;debug&quot;

# [[layers]]
# name = &quot;floobits&quot;

# [[layers]]
# name = &quot;fzf&quot;

[[layers]]
name = &quot;git&quot;
git-plugin = &quot;fugitive&quot;

# [[layers]]
#   name = &quot;lang#c&quot;
#   clang_executable = &quot;/usr/bin/clang&quot;
#   [layer.clang_std]
#     c = &quot;c11&quot;
#     cpp = &quot;c++1z&quot;

# [[layers]]
# name = &quot;lang#go&quot;

[[layers]]
  name = &quot;tmux&quot;
  # tmux_navigator_modifier = &quot;alt&quot;

[[layers]]
  name = &quot;leaderf&quot;

[[layers]]
  name = &quot;sudo&quot;

[[layers]]
  name = &quot;tags&quot;

[[layers]]
 name = &quot;tools&quot;

[[layers]]
 name = 'core'
 # filetree_show_hidden = true

# [[layers]]
#  name = &quot;core#statusline&quot;
#  enable = false

[[layers]]
  name = &quot;ui&quot;
  enable_sidebar = true

# [[layers]]
# name = &quot;gtags&quot;
# gtagslabel = &quot;ctags&quot;

# [custom_plugins]]
# name = &quot;Shougo/dein.vim&quot;

# [[custom_plugins]]
  # name = 'liuchengxu/vista.vim'
</code></pre>
<pre><code class="language-bash">set tabstop=4
set expandtab
set shiftwidth=4
nnoremap &lt;F9&gt; :set invpaste paste?&lt;CR&gt;
set pastetoggle=&lt;F9&gt;
set showmode
set cmdheight=1

&quot; let g:EasyMotion_do_mapping = 1

&quot; filetype plugin indent on
&quot; syntax enable
&quot;
&quot; Default value is &quot;normal&quot;, Setting this option to &quot;high&quot; or &quot;low&quot; does use the
&quot; same Solarized palette but simply shifts some values up or down in order to
&quot; expand or compress the tonal range displayed.
let g:neosolarized_contrast = &quot;normal&quot;

&quot; Special characters such as trailing whitespace, tabs, newlines, when displayed
&quot; using &quot;:set list&quot; can be set to one of three levels depending on your needs.
&quot; Default value is &quot;normal&quot;. Provide &quot;high&quot; and &quot;low&quot; options.
let g:neosolarized_visibility = &quot;normal&quot;

&quot; I make vertSplitBar a transparent background color. If you like the origin
&quot; solarized vertSplitBar style more, set this value to 0.
let g:neosolarized_vertSplitBgTrans = 1

&quot; If you wish to enable/disable NeoSolarized from displaying bold, underlined
&quot; or italicized&quot; typefaces, simply assign 1 or 0 to the appropriate variable.
&quot; Default values:
let g:neosolarized_bold = 1
let g:neosolarized_underline = 1
let g:neosolarized_italic = 0

&quot; Used to enable/disable &quot;bold as bright&quot; in Neovim terminal. If colors of bold
&quot; text output by commands like `ls` aren't what you expect, you might want to
&quot; try disabling this option. Default value:
let g:neosolarized_termBoldAsBright = 1
</code></pre>
<pre><code class="language-bash"># coc.nvim config
reference: https://github.com/neoclide/coc.nvim
https://github.com/neoclide/coc.nvim/wiki
https://github.com/MaskRay/ccls/wiki
https://clangd.llvm.org/

# configurate for coc.nvim
Open config file with command :CocConfig
{
  &quot;languageserver&quot;: {
    &quot;ccls&quot;: {
      &quot;command&quot;: &quot;ccls&quot;,
      &quot;filetypes&quot;: [&quot;c&quot;, &quot;cpp&quot;, &quot;cuda&quot;, &quot;objc&quot;, &quot;objcpp&quot;],
      &quot;rootPatterns&quot;: [&quot;.ccls-root&quot;, &quot;compile_commands.json&quot;],
      &quot;initializationOptions&quot;: {
        &quot;cache&quot;: {
          &quot;directory&quot;: &quot;.ccls-cache&quot;
        },
        &quot;client&quot;: {
          &quot;snippetSupport&quot;: true
        }
      }
    }
  }
}

#Set project for coc.nvim(compile_commands.json and .ccls)
cmake -H. -BDebug -DCMAKE_BUILD_TYPE=Debug -DCMAKE_EXPORT_COMPILE_COMMANDS=YES
ln -s Debug/compile_commands.json .

cat .ccls
%compile_commands.json
%c -std=c11
%cpp -std=c++14
%c %cpp -pthread
%h %hpp --include=Global.h
-Iinc
</code></pre>
<pre><code class="language-bash">cd ~/.cache/vimfiles/repos/github.com/Valloric/YouCompleteMe
git submodule update --init --recursive
dnf install -y cmake python3-devel gcc-c++ clang golang
python3 install.py --clang-completer

cd /root/.SpaceVim
-----------------------------------------------
modified: config/plugins_before/YouCompleteMe.vim
-----------------------------------------------
@@ -1,4 +1,4 @@
-&quot;let g:ycm_global_ycm_extra_conf = '~/.ycm_extra_conf.py'
+let g:ycm_global_ycm_extra_conf = '~/.cache/vimfiles/repos/github.com/Valloric/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py'
 &quot;let g:ycm_confirm_extra_conf = 0
 let g:ycm_collect_identifiers_from_tags_files =
       \ get(g:, 'ycm_collect_identifiers_from_tags_files', 1)
-----------------------------------------------
modified: vimrc
-----------------------------------------------
@@ -25,3 +25,9 @@ if 1
     execute 'source' fnamemodify(expand('&lt;sfile&gt;'), ':h').'/config/main.vim'
 endif

cat ~/.Spacevim/vimrc
 &quot; vim:set et sw=2
+set tabstop=4
+set expandtab
+set shiftwidth=4
+nnoremap &lt;F9&gt; :set invpaste paste?&lt;CR&gt;
+set pastetoggle=&lt;F9&gt;
+set showmode

vim ~/.cache/vimfiles/repos/github.com/Valloric/YouCompleteMe/third_party/ycmd/.ycm_extra_conf.py
-----------------------------------------------
modified: .ycm_extra_conf.py
-----------------------------------------------
@@ -85,6 +85,18 @@ get_python_inc(),
 'cpp/ycm/tests/gmock/include',
 '-isystem',
 'cpp/ycm/benchmarks/benchmark/include',
+'-I',
+'/usr/local/include',
+'-I',
+'/usr/include',
+'-isystem',
+'/usr/lib/gcc/x86_64-redhat-linux/9/include',
+'-isystem',
+'/usr/include/c++/9',
+'-isystem',
+'/usr/include/c++/9/bits',
+'-isystem',
+'/usr/include/linux',
 ]

# oh-my-tmux
$ cd
$ git clone https://github.com/gpakosz/.tmux.git
$ ln -s -f .tmux/.tmux.conf
$ cp .tmux/.tmux.conf.local .

dnf install -y tmuxinator
echo &quot;export EDITOR='vim'&quot; &gt;&gt; ~/.zshrc
echo &quot;source ~/.bin/.tmuxinator.zsh&quot; &gt;&gt; ~/.zshrc
cat ~/.bin/.tmuxinator.zsh
#compdef _tmuxinator tmuxinator

_tmuxinator() {
  local commands projects
  commands=(${(f)&quot;$(tmuxinator commands zsh)&quot;})
  projects=(${(f)&quot;$(tmuxinator completions start)&quot;})

  if (( CURRENT == 2 )); then
    _alternative \
      'commands:: _describe -t commands &quot;tmuxinator subcommands&quot; commands' \
      'projects:: _describe -t projects &quot;tmuxinator projects&quot; projects'
  elif (( CURRENT == 3)); then
    case $words[2] in
      copy|cp|c|debug|delete|rm|open|o|start|s|edit|e)
        _arguments '*:projects:($projects)'
      ;;
    esac
  fi

  return
}

complete -F _tmuxinator tmuxinator mux
alias mux=&quot;tmuxinator&quot;
# Local Variables:
# mode: Shell-Script
# sh-indentation: 2
# indent-tabs-mode: nil
# sh-basic-offset: 2
# End:
# vim: ft=zsh sw=2 ts=2 et

tmuxinator new YOUR_PROJECT
tmuxinator edit YOUR_PROJECT
tmuxinator start YOUR_PROJECT
tmuxinator stop YOUR_PROJECT

vim ~/.tmux.conf
...
# replace C-b by C-a instead of using both prefixes
set-option -g prefix2 `

unbind '&quot;'
bind - splitw -v
unbind %
bind | splitw -h
# move status line to top
set -g status-position bottom

cd ~/.tmux
mkdir plugins
git clone https://github.com/tmux-plugins/tmux-resurrect.git
cd ~/.tmux/plugins
git clone https://github.com/tmux-plugins/tmux-continuum.git

run-shell ~/.tmux/plugins/tmux-resurrect/resurrect.tmux
run-shell ~/.tmux/plugins/tmux-continuum/continuum.tmux

vim  ~/.tmux.conf
...
# set -g @continuum-save-interval '1440'
set -g @continuum-save-interval '0'
set -g @continuum-restore 'on'
</code></pre>
<h2 id="terminal-true-color-support">terminal true-color support</h2>
<p>xshell tools - configuation - advance - select using true-color<br>
reference：https://github.com/icymind/NeoSolarized<br>
https://gist.github.com/XVilka/8346728</p>
<p>code font: JetBrains Mono/Cascadia Code/Consolas<br>
https://www.jetbrains.com/lp/mono/</p>
<p>dnf install -y ccls bear<br>
if failed to install coc.nvim, execute <code>yarn config set &quot;strict-ssl&quot; false -g</code></p>
<p>[coc.nvim] error: Some plugin change completeopt on insert mode<br>
rm -rf <code>find ~ -name 'deoplete*'</code></p>
<h2 id="start-isulad-on-high-fedora-version-eg31">start iSulad on high Fedora version (eg:31)</h2>
<pre><code class="language-bash"># sudo grubby --update-kernel=ALL --args=&quot;systemd.unified_cgroup_hierarchy=0&quot;    # use cgroup v1
# sudo grubby --update-kernel=ALL --args=&quot;systemd.unified_cgroup_hierarchy=1&quot;    # use cgroup v2

$ sudo dnf install -y grubby
$ sudo grubby --update-kernel=ALL --args=&quot;systemd.unified_cgroup_hierarchy=0&quot;
$ sudo reboot
</code></pre>
<h2 id="developingdebuging-isulad">Developing/Debuging iSulad</h2>
<pre><code class="language-bash">dnf install valgrind gdb gdb-gdbserver tcpdump ystemtap ltrace strace
dnf group install 'Development Tools' 
dnf install gcc rpm-build rpm-devel rpmlint make python bash coreutils diffutils patch rpmdevtools

ulimit -c unlimited
echo &quot;1&quot; &gt; /proc/sys/kernel/core_uses_pid
echo &quot;/corefile/core-%e-%p-%t&quot; &gt; /proc/sys/kernel/core_pattern

valgrind --tool=memcheck --leak-check=full --show-leak-kinds=all --track-origins=yes --leak-resolution=high --show-reachable=yes --log-file=valgrind_memcheck.log -v isulad
</code></pre>
<h3 id="isulad-network-debug">iSulad Network Debug</h3>
<pre><code class="language-bash">openssl x509 -in cert.pem -noout -text
./testssl.sh IP:port
sslscan --tlsall IP:port
openssl s_client -connect IP:port
tcpdump port $port
tcpdump -i xxx port $port
tshark -i xxx
</code></pre>
<h2 id=""></h2>
]]></content>
    </entry>
</feed>